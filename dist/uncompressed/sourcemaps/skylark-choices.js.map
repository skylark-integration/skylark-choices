{"version":3,"sources":["skylark-choices.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-choices.js","sourcesContent":["define('skylark-choices/vendors/fuse',[],function () { \r\n  'use strict';\r\n\r\n  function _typeof(obj) {\r\n    \"@babel/helpers - typeof\";\r\n\r\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\r\n      _typeof = function (obj) {\r\n        return typeof obj;\r\n      };\r\n    } else {\r\n      _typeof = function (obj) {\r\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\r\n      };\r\n    }\r\n\r\n    return _typeof(obj);\r\n  }\r\n\r\n  function _classCallCheck(instance, Constructor) {\r\n    if (!(instance instanceof Constructor)) {\r\n      throw new TypeError(\"Cannot call a class as a function\");\r\n    }\r\n  }\r\n\r\n  function _defineProperties(target, props) {\r\n    for (var i = 0; i < props.length; i++) {\r\n      var descriptor = props[i];\r\n      descriptor.enumerable = descriptor.enumerable || false;\r\n      descriptor.configurable = true;\r\n      if (\"value\" in descriptor) descriptor.writable = true;\r\n      Object.defineProperty(target, descriptor.key, descriptor);\r\n    }\r\n  }\r\n\r\n  function _createClass(Constructor, protoProps, staticProps) {\r\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n    if (staticProps) _defineProperties(Constructor, staticProps);\r\n    return Constructor;\r\n  }\r\n\r\n  function _defineProperty(obj, key, value) {\r\n    if (key in obj) {\r\n      Object.defineProperty(obj, key, {\r\n        value: value,\r\n        enumerable: true,\r\n        configurable: true,\r\n        writable: true\r\n      });\r\n    } else {\r\n      obj[key] = value;\r\n    }\r\n\r\n    return obj;\r\n  }\r\n\r\n  function ownKeys(object, enumerableOnly) {\r\n    var keys = Object.keys(object);\r\n\r\n    if (Object.getOwnPropertySymbols) {\r\n      var symbols = Object.getOwnPropertySymbols(object);\r\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\r\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\r\n      });\r\n      keys.push.apply(keys, symbols);\r\n    }\r\n\r\n    return keys;\r\n  }\r\n\r\n  function _objectSpread2(target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = arguments[i] != null ? arguments[i] : {};\r\n\r\n      if (i % 2) {\r\n        ownKeys(Object(source), true).forEach(function (key) {\r\n          _defineProperty(target, key, source[key]);\r\n        });\r\n      } else if (Object.getOwnPropertyDescriptors) {\r\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\r\n      } else {\r\n        ownKeys(Object(source)).forEach(function (key) {\r\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\r\n        });\r\n      }\r\n    }\r\n\r\n    return target;\r\n  }\r\n\r\n  function _inherits(subClass, superClass) {\r\n    if (typeof superClass !== \"function\" && superClass !== null) {\r\n      throw new TypeError(\"Super expression must either be null or a function\");\r\n    }\r\n\r\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\r\n      constructor: {\r\n        value: subClass,\r\n        writable: true,\r\n        configurable: true\r\n      }\r\n    });\r\n    if (superClass) _setPrototypeOf(subClass, superClass);\r\n  }\r\n\r\n  function _getPrototypeOf(o) {\r\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\r\n      return o.__proto__ || Object.getPrototypeOf(o);\r\n    };\r\n    return _getPrototypeOf(o);\r\n  }\r\n\r\n  function _setPrototypeOf(o, p) {\r\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\r\n      o.__proto__ = p;\r\n      return o;\r\n    };\r\n\r\n    return _setPrototypeOf(o, p);\r\n  }\r\n\r\n  function _isNativeReflectConstruct() {\r\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\r\n    if (Reflect.construct.sham) return false;\r\n    if (typeof Proxy === \"function\") return true;\r\n\r\n    try {\r\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function _assertThisInitialized(self) {\r\n    if (self === void 0) {\r\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\r\n    }\r\n\r\n    return self;\r\n  }\r\n\r\n  function _possibleConstructorReturn(self, call) {\r\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\r\n      return call;\r\n    }\r\n\r\n    return _assertThisInitialized(self);\r\n  }\r\n\r\n  function _createSuper(Derived) {\r\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\r\n\r\n    return function _createSuperInternal() {\r\n      var Super = _getPrototypeOf(Derived),\r\n          result;\r\n\r\n      if (hasNativeReflectConstruct) {\r\n        var NewTarget = _getPrototypeOf(this).constructor;\r\n\r\n        result = Reflect.construct(Super, arguments, NewTarget);\r\n      } else {\r\n        result = Super.apply(this, arguments);\r\n      }\r\n\r\n      return _possibleConstructorReturn(this, result);\r\n    };\r\n  }\r\n\r\n  function _toConsumableArray(arr) {\r\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\r\n  }\r\n\r\n  function _arrayWithoutHoles(arr) {\r\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\r\n  }\r\n\r\n  function _iterableToArray(iter) {\r\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\r\n  }\r\n\r\n  function _unsupportedIterableToArray(o, minLen) {\r\n    if (!o) return;\r\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\r\n    var n = Object.prototype.toString.call(o).slice(8, -1);\r\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\r\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\r\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\r\n  }\r\n\r\n  function _arrayLikeToArray(arr, len) {\r\n    if (len == null || len > arr.length) len = arr.length;\r\n\r\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\r\n\r\n    return arr2;\r\n  }\r\n\r\n  function _nonIterableSpread() {\r\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\r\n  }\r\n\r\n  function isArray(value) {\r\n    return !Array.isArray ? getTag(value) === '[object Array]' : Array.isArray(value);\r\n  } // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\r\n\r\n  var INFINITY = 1 / 0;\r\n  function baseToString(value) {\r\n    // Exit early for strings to avoid a performance hit in some environments.\r\n    if (typeof value == 'string') {\r\n      return value;\r\n    }\r\n\r\n    var result = value + '';\r\n    return result == '0' && 1 / value == -INFINITY ? '-0' : result;\r\n  }\r\n  function toString(value) {\r\n    return value == null ? '' : baseToString(value);\r\n  }\r\n  function isString(value) {\r\n    return typeof value === 'string';\r\n  }\r\n  function isNumber(value) {\r\n    return typeof value === 'number';\r\n  } // Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\r\n\r\n  function isBoolean(value) {\r\n    return value === true || value === false || isObjectLike(value) && getTag(value) == '[object Boolean]';\r\n  }\r\n  function isObject(value) {\r\n    return _typeof(value) === 'object';\r\n  } // Checks if `value` is object-like.\r\n\r\n  function isObjectLike(value) {\r\n    return isObject(value) && value !== null;\r\n  }\r\n  function isDefined(value) {\r\n    return value !== undefined && value !== null;\r\n  }\r\n  function isBlank(value) {\r\n    return !value.trim().length;\r\n  } // Gets the `toStringTag` of `value`.\r\n  // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\r\n\r\n  function getTag(value) {\r\n    return value == null ? value === undefined ? '[object Undefined]' : '[object Null]' : Object.prototype.toString.call(value);\r\n  }\r\n\r\n  var EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';\r\n  var INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\r\n  var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = function LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key) {\r\n    return \"Invalid value for key \".concat(key);\r\n  };\r\n  var PATTERN_LENGTH_TOO_LARGE = function PATTERN_LENGTH_TOO_LARGE(max) {\r\n    return \"Pattern length exceeds max of \".concat(max, \".\");\r\n  };\r\n  var MISSING_KEY_PROPERTY = function MISSING_KEY_PROPERTY(name) {\r\n    return \"Missing \".concat(name, \" property in key\");\r\n  };\r\n  var INVALID_KEY_WEIGHT_VALUE = function INVALID_KEY_WEIGHT_VALUE(key) {\r\n    return \"Property 'weight' in key '\".concat(key, \"' must be a positive integer\");\r\n  };\r\n\r\n  var hasOwn = Object.prototype.hasOwnProperty;\r\n\r\n  var KeyStore = /*#__PURE__*/function () {\r\n    function KeyStore(keys) {\r\n      var _this = this;\r\n\r\n      _classCallCheck(this, KeyStore);\r\n\r\n      this._keys = [];\r\n      this._keyMap = {};\r\n      var totalWeight = 0;\r\n      keys.forEach(function (key) {\r\n        var obj = createKey(key);\r\n        totalWeight += obj.weight;\r\n\r\n        _this._keys.push(obj);\r\n\r\n        _this._keyMap[obj.id] = obj;\r\n        totalWeight += obj.weight;\r\n      }); // Normalize weights so that their sum is equal to 1\r\n\r\n      this._keys.forEach(function (key) {\r\n        key.weight /= totalWeight;\r\n      });\r\n    }\r\n\r\n    _createClass(KeyStore, [{\r\n      key: \"get\",\r\n      value: function get(keyId) {\r\n        return this._keyMap[keyId];\r\n      }\r\n    }, {\r\n      key: \"keys\",\r\n      value: function keys() {\r\n        return this._keys;\r\n      }\r\n    }, {\r\n      key: \"toJSON\",\r\n      value: function toJSON() {\r\n        return JSON.stringify(this._keys);\r\n      }\r\n    }]);\r\n\r\n    return KeyStore;\r\n  }();\r\n  function createKey(key) {\r\n    var path = null;\r\n    var id = null;\r\n    var src = null;\r\n    var weight = 1;\r\n\r\n    if (isString(key) || isArray(key)) {\r\n      src = key;\r\n      path = createKeyPath(key);\r\n      id = createKeyId(key);\r\n    } else {\r\n      if (!hasOwn.call(key, 'name')) {\r\n        throw new Error(MISSING_KEY_PROPERTY('name'));\r\n      }\r\n\r\n      var name = key.name;\r\n      src = name;\r\n\r\n      if (hasOwn.call(key, 'weight')) {\r\n        weight = key.weight;\r\n\r\n        if (weight <= 0) {\r\n          throw new Error(INVALID_KEY_WEIGHT_VALUE(name));\r\n        }\r\n      }\r\n\r\n      path = createKeyPath(name);\r\n      id = createKeyId(name);\r\n    }\r\n\r\n    return {\r\n      path: path,\r\n      id: id,\r\n      weight: weight,\r\n      src: src\r\n    };\r\n  }\r\n  function createKeyPath(key) {\r\n    return isArray(key) ? key : key.split('.');\r\n  }\r\n  function createKeyId(key) {\r\n    return isArray(key) ? key.join('.') : key;\r\n  }\r\n\r\n  function get(obj, path) {\r\n    var list = [];\r\n    var arr = false;\r\n\r\n    var deepGet = function deepGet(obj, path, index) {\r\n      if (!isDefined(obj)) {\r\n        return;\r\n      }\r\n\r\n      if (!path[index]) {\r\n        // If there's no path left, we've arrived at the object we care about.\r\n        list.push(obj);\r\n      } else {\r\n        var key = path[index];\r\n        var value = obj[key];\r\n\r\n        if (!isDefined(value)) {\r\n          return;\r\n        } // If we're at the last value in the path, and if it's a string/number/bool,\r\n        // add it to the list\r\n\r\n\r\n        if (index === path.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {\r\n          list.push(toString(value));\r\n        } else if (isArray(value)) {\r\n          arr = true; // Search each item in the array.\r\n\r\n          for (var i = 0, len = value.length; i < len; i += 1) {\r\n            deepGet(value[i], path, index + 1);\r\n          }\r\n        } else if (path.length) {\r\n          // An object. Recurse further.\r\n          deepGet(value, path, index + 1);\r\n        }\r\n      }\r\n    }; // Backwards compatibility (since path used to be a string)\r\n\r\n\r\n    deepGet(obj, isString(path) ? path.split('.') : path, 0);\r\n    return arr ? list : list[0];\r\n  }\r\n\r\n  var MatchOptions = {\r\n    // Whether the matches should be included in the result set. When `true`, each record in the result\r\n    // set will include the indices of the matched characters.\r\n    // These can consequently be used for highlighting purposes.\r\n    includeMatches: false,\r\n    // When `true`, the matching function will continue to the end of a search pattern even if\r\n    // a perfect match has already been located in the string.\r\n    findAllMatches: false,\r\n    // Minimum number of characters that must be matched before a result is considered a match\r\n    minMatchCharLength: 1\r\n  };\r\n  var BasicOptions = {\r\n    // When `true`, the algorithm continues searching to the end of the input even if a perfect\r\n    // match is found before the end of the same input.\r\n    isCaseSensitive: false,\r\n    // When true, the matching function will continue to the end of a search pattern even if\r\n    includeScore: false,\r\n    // List of properties that will be searched. This also supports nested properties.\r\n    keys: [],\r\n    // Whether to sort the result list, by score\r\n    shouldSort: true,\r\n    // Default sort function: sort by ascending score, ascending index\r\n    sortFn: function sortFn(a, b) {\r\n      return a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1;\r\n    }\r\n  };\r\n  var FuzzyOptions = {\r\n    // Approximately where in the text is the pattern expected to be found?\r\n    location: 0,\r\n    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\r\n    // (of both letters and location), a threshold of '1.0' would match anything.\r\n    threshold: 0.6,\r\n    // Determines how close the match must be to the fuzzy location (specified above).\r\n    // An exact letter match which is 'distance' characters away from the fuzzy location\r\n    // would score as a complete mismatch. A distance of '0' requires the match be at\r\n    // the exact location specified, a threshold of '1000' would require a perfect match\r\n    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\r\n    distance: 100\r\n  };\r\n  var AdvancedOptions = {\r\n    // When `true`, it enables the use of unix-like search commands\r\n    useExtendedSearch: false,\r\n    // The get function to use when fetching an object's properties.\r\n    // The default will search nested paths *ie foo.bar.baz*\r\n    getFn: get,\r\n    // When `true`, search will ignore `location` and `distance`, so it won't matter\r\n    // where in the string the pattern appears.\r\n    // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\r\n    ignoreLocation: false,\r\n    // When `true`, the calculation for the relevance score (used for sorting) will\r\n    // ignore the field-length norm.\r\n    // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\r\n    ignoreFieldNorm: false\r\n  };\r\n  var Config = _objectSpread2({}, BasicOptions, {}, MatchOptions, {}, FuzzyOptions, {}, AdvancedOptions);\r\n\r\n  var SPACE = /[^ ]+/g; // Field-length norm: the shorter the field, the higher the weight.\r\n  // Set to 3 decimals to reduce index size.\r\n\r\n  function norm() {\r\n    var mantissa = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\r\n    var cache = new Map();\r\n    var m = Math.pow(10, mantissa);\r\n    return {\r\n      get: function get(value) {\r\n        var numTokens = value.match(SPACE).length;\r\n\r\n        if (cache.has(numTokens)) {\r\n          return cache.get(numTokens);\r\n        }\r\n\r\n        var norm = 1 / Math.sqrt(numTokens); // In place of `toFixed(mantissa)`, for faster computation\r\n\r\n        var n = parseFloat(Math.round(norm * m) / m);\r\n        cache.set(numTokens, n);\r\n        return n;\r\n      },\r\n      clear: function clear() {\r\n        cache.clear();\r\n      }\r\n    };\r\n  }\r\n\r\n  var FuseIndex = /*#__PURE__*/function () {\r\n    function FuseIndex() {\r\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\r\n          _ref$getFn = _ref.getFn,\r\n          getFn = _ref$getFn === void 0 ? Config.getFn : _ref$getFn;\r\n\r\n      _classCallCheck(this, FuseIndex);\r\n\r\n      this.norm = norm(3);\r\n      this.getFn = getFn;\r\n      this.isCreated = false;\r\n      this.setIndexRecords();\r\n    }\r\n\r\n    _createClass(FuseIndex, [{\r\n      key: \"setSources\",\r\n      value: function setSources() {\r\n        var docs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\r\n        this.docs = docs;\r\n      }\r\n    }, {\r\n      key: \"setIndexRecords\",\r\n      value: function setIndexRecords() {\r\n        var records = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\r\n        this.records = records;\r\n      }\r\n    }, {\r\n      key: \"setKeys\",\r\n      value: function setKeys() {\r\n        var _this = this;\r\n\r\n        var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\r\n        this.keys = keys;\r\n        this._keysMap = {};\r\n        keys.forEach(function (key, idx) {\r\n          _this._keysMap[key.id] = idx;\r\n        });\r\n      }\r\n    }, {\r\n      key: \"create\",\r\n      value: function create() {\r\n        var _this2 = this;\r\n\r\n        if (this.isCreated || !this.docs.length) {\r\n          return;\r\n        }\r\n\r\n        this.isCreated = true; // List is Array<String>\r\n\r\n        if (isString(this.docs[0])) {\r\n          this.docs.forEach(function (doc, docIndex) {\r\n            _this2._addString(doc, docIndex);\r\n          });\r\n        } else {\r\n          // List is Array<Object>\r\n          this.docs.forEach(function (doc, docIndex) {\r\n            _this2._addObject(doc, docIndex);\r\n          });\r\n        }\r\n\r\n        this.norm.clear();\r\n      } // Adds a doc to the end of the index\r\n\r\n    }, {\r\n      key: \"add\",\r\n      value: function add(doc) {\r\n        var idx = this.size();\r\n\r\n        if (isString(doc)) {\r\n          this._addString(doc, idx);\r\n        } else {\r\n          this._addObject(doc, idx);\r\n        }\r\n      } // Removes the doc at the specified index of the index\r\n\r\n    }, {\r\n      key: \"removeAt\",\r\n      value: function removeAt(idx) {\r\n        this.records.splice(idx, 1); // Change ref index of every subsquent doc\r\n\r\n        for (var i = idx, len = this.size(); i < len; i += 1) {\r\n          this.records[i].i -= 1;\r\n        }\r\n      }\r\n    }, {\r\n      key: \"getValueForItemAtKeyId\",\r\n      value: function getValueForItemAtKeyId(item, keyId) {\r\n        return item[this._keysMap[keyId]];\r\n      }\r\n    }, {\r\n      key: \"size\",\r\n      value: function size() {\r\n        return this.records.length;\r\n      }\r\n    }, {\r\n      key: \"_addString\",\r\n      value: function _addString(doc, docIndex) {\r\n        if (!isDefined(doc) || isBlank(doc)) {\r\n          return;\r\n        }\r\n\r\n        var record = {\r\n          v: doc,\r\n          i: docIndex,\r\n          n: this.norm.get(doc)\r\n        };\r\n        this.records.push(record);\r\n      }\r\n    }, {\r\n      key: \"_addObject\",\r\n      value: function _addObject(doc, docIndex) {\r\n        var _this3 = this;\r\n\r\n        var record = {\r\n          i: docIndex,\r\n          $: {}\r\n        }; // Iterate over every key (i.e, path), and fetch the value at that key\r\n\r\n        this.keys.forEach(function (key, keyIndex) {\r\n          // console.log(key)\r\n          var value = _this3.getFn(doc, key.path);\r\n\r\n          if (!isDefined(value)) {\r\n            return;\r\n          }\r\n\r\n          if (isArray(value)) {\r\n            (function () {\r\n              var subRecords = [];\r\n              var stack = [{\r\n                nestedArrIndex: -1,\r\n                value: value\r\n              }];\r\n\r\n              while (stack.length) {\r\n                var _stack$pop = stack.pop(),\r\n                    nestedArrIndex = _stack$pop.nestedArrIndex,\r\n                    _value = _stack$pop.value;\r\n\r\n                if (!isDefined(_value)) {\r\n                  continue;\r\n                }\r\n\r\n                if (isString(_value) && !isBlank(_value)) {\r\n                  var subRecord = {\r\n                    v: _value,\r\n                    i: nestedArrIndex,\r\n                    n: _this3.norm.get(_value)\r\n                  };\r\n                  subRecords.push(subRecord);\r\n                } else if (isArray(_value)) {\r\n                  _value.forEach(function (item, k) {\r\n                    stack.push({\r\n                      nestedArrIndex: k,\r\n                      value: item\r\n                    });\r\n                  });\r\n                }\r\n              }\r\n\r\n              record.$[keyIndex] = subRecords;\r\n            })();\r\n          } else if (!isBlank(value)) {\r\n            var subRecord = {\r\n              v: value,\r\n              n: _this3.norm.get(value)\r\n            };\r\n            record.$[keyIndex] = subRecord;\r\n          }\r\n        });\r\n        this.records.push(record);\r\n      }\r\n    }, {\r\n      key: \"toJSON\",\r\n      value: function toJSON() {\r\n        return {\r\n          keys: this.keys,\r\n          records: this.records\r\n        };\r\n      }\r\n    }]);\r\n\r\n    return FuseIndex;\r\n  }();\r\n  function createIndex(keys, docs) {\r\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\r\n        _ref2$getFn = _ref2.getFn,\r\n        getFn = _ref2$getFn === void 0 ? Config.getFn : _ref2$getFn;\r\n\r\n    var myIndex = new FuseIndex({\r\n      getFn: getFn\r\n    });\r\n    myIndex.setKeys(keys.map(createKey));\r\n    myIndex.setSources(docs);\r\n    myIndex.create();\r\n    return myIndex;\r\n  }\r\n  function parseIndex(data) {\r\n    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\r\n        _ref3$getFn = _ref3.getFn,\r\n        getFn = _ref3$getFn === void 0 ? Config.getFn : _ref3$getFn;\r\n\r\n    var keys = data.keys,\r\n        records = data.records;\r\n    var myIndex = new FuseIndex({\r\n      getFn: getFn\r\n    });\r\n    myIndex.setKeys(keys);\r\n    myIndex.setIndexRecords(records);\r\n    return myIndex;\r\n  }\r\n\r\n  function computeScore(pattern) {\r\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\r\n        _ref$errors = _ref.errors,\r\n        errors = _ref$errors === void 0 ? 0 : _ref$errors,\r\n        _ref$currentLocation = _ref.currentLocation,\r\n        currentLocation = _ref$currentLocation === void 0 ? 0 : _ref$currentLocation,\r\n        _ref$expectedLocation = _ref.expectedLocation,\r\n        expectedLocation = _ref$expectedLocation === void 0 ? 0 : _ref$expectedLocation,\r\n        _ref$distance = _ref.distance,\r\n        distance = _ref$distance === void 0 ? Config.distance : _ref$distance,\r\n        _ref$ignoreLocation = _ref.ignoreLocation,\r\n        ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;\r\n\r\n    var accuracy = errors / pattern.length;\r\n\r\n    if (ignoreLocation) {\r\n      return accuracy;\r\n    }\r\n\r\n    var proximity = Math.abs(expectedLocation - currentLocation);\r\n\r\n    if (!distance) {\r\n      // Dodge divide by zero error.\r\n      return proximity ? 1.0 : accuracy;\r\n    }\r\n\r\n    return accuracy + proximity / distance;\r\n  }\r\n\r\n  function convertMaskToIndices() {\r\n    var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\r\n    var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Config.minMatchCharLength;\r\n    var indices = [];\r\n    var start = -1;\r\n    var end = -1;\r\n    var i = 0;\r\n\r\n    for (var len = matchmask.length; i < len; i += 1) {\r\n      var match = matchmask[i];\r\n\r\n      if (match && start === -1) {\r\n        start = i;\r\n      } else if (!match && start !== -1) {\r\n        end = i - 1;\r\n\r\n        if (end - start + 1 >= minMatchCharLength) {\r\n          indices.push([start, end]);\r\n        }\r\n\r\n        start = -1;\r\n      }\r\n    } // (i-1 - start) + 1 => i - start\r\n\r\n\r\n    if (matchmask[i - 1] && i - start >= minMatchCharLength) {\r\n      indices.push([start, i - 1]);\r\n    }\r\n\r\n    return indices;\r\n  }\r\n\r\n  // Machine word size\r\n  var MAX_BITS = 32;\r\n\r\n  function search(text, pattern, patternAlphabet) {\r\n    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\r\n        _ref$location = _ref.location,\r\n        location = _ref$location === void 0 ? Config.location : _ref$location,\r\n        _ref$distance = _ref.distance,\r\n        distance = _ref$distance === void 0 ? Config.distance : _ref$distance,\r\n        _ref$threshold = _ref.threshold,\r\n        threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,\r\n        _ref$findAllMatches = _ref.findAllMatches,\r\n        findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,\r\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\r\n        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,\r\n        _ref$includeMatches = _ref.includeMatches,\r\n        includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,\r\n        _ref$ignoreLocation = _ref.ignoreLocation,\r\n        ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;\r\n\r\n    if (pattern.length > MAX_BITS) {\r\n      throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));\r\n    }\r\n\r\n    var patternLen = pattern.length; // Set starting location at beginning text and initialize the alphabet.\r\n\r\n    var textLen = text.length; // Handle the case when location > text.length\r\n\r\n    var expectedLocation = Math.max(0, Math.min(location, textLen)); // Highest score beyond which we give up.\r\n\r\n    var currentThreshold = threshold; // Is there a nearby exact match? (speedup)\r\n\r\n    var bestLocation = expectedLocation; // Performance: only computer matches when the minMatchCharLength > 1\r\n    // OR if `includeMatches` is true.\r\n\r\n    var computeMatches = minMatchCharLength > 1 || includeMatches; // A mask of the matches, used for building the indices\r\n\r\n    var matchMask = computeMatches ? Array(textLen) : [];\r\n    var index; // Get all exact matches, here for speed up\r\n\r\n    while ((index = text.indexOf(pattern, bestLocation)) > -1) {\r\n      var score = computeScore(pattern, {\r\n        currentLocation: index,\r\n        expectedLocation: expectedLocation,\r\n        distance: distance,\r\n        ignoreLocation: ignoreLocation\r\n      });\r\n      currentThreshold = Math.min(score, currentThreshold);\r\n      bestLocation = index + patternLen;\r\n\r\n      if (computeMatches) {\r\n        var i = 0;\r\n\r\n        while (i < patternLen) {\r\n          matchMask[index + i] = 1;\r\n          i += 1;\r\n        }\r\n      }\r\n    } // Reset the best location\r\n\r\n\r\n    bestLocation = -1;\r\n    var lastBitArr = [];\r\n    var finalScore = 1;\r\n    var binMax = patternLen + textLen;\r\n    var mask = 1 << patternLen - 1;\r\n\r\n    for (var _i = 0; _i < patternLen; _i += 1) {\r\n      // Scan for the best match; each iteration allows for one more error.\r\n      // Run a binary search to determine how far from the match location we can stray\r\n      // at this error level.\r\n      var binMin = 0;\r\n      var binMid = binMax;\r\n\r\n      while (binMin < binMid) {\r\n        var _score2 = computeScore(pattern, {\r\n          errors: _i,\r\n          currentLocation: expectedLocation + binMid,\r\n          expectedLocation: expectedLocation,\r\n          distance: distance,\r\n          ignoreLocation: ignoreLocation\r\n        });\r\n\r\n        if (_score2 <= currentThreshold) {\r\n          binMin = binMid;\r\n        } else {\r\n          binMax = binMid;\r\n        }\r\n\r\n        binMid = Math.floor((binMax - binMin) / 2 + binMin);\r\n      } // Use the result from this iteration as the maximum for the next.\r\n\r\n\r\n      binMax = binMid;\r\n      var start = Math.max(1, expectedLocation - binMid + 1);\r\n      var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen; // Initialize the bit array\r\n\r\n      var bitArr = Array(finish + 2);\r\n      bitArr[finish + 1] = (1 << _i) - 1;\r\n\r\n      for (var j = finish; j >= start; j -= 1) {\r\n        var currentLocation = j - 1;\r\n        var charMatch = patternAlphabet[text.charAt(currentLocation)];\r\n\r\n        if (computeMatches) {\r\n          // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\r\n          matchMask[currentLocation] = +!!charMatch;\r\n        } // First pass: exact match\r\n\r\n\r\n        bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch; // Subsequent passes: fuzzy match\r\n\r\n        if (_i) {\r\n          bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\r\n        }\r\n\r\n        if (bitArr[j] & mask) {\r\n          finalScore = computeScore(pattern, {\r\n            errors: _i,\r\n            currentLocation: currentLocation,\r\n            expectedLocation: expectedLocation,\r\n            distance: distance,\r\n            ignoreLocation: ignoreLocation\r\n          }); // This match will almost certainly be better than any existing match.\r\n          // But check anyway.\r\n\r\n          if (finalScore <= currentThreshold) {\r\n            // Indeed it is\r\n            currentThreshold = finalScore;\r\n            bestLocation = currentLocation; // Already passed `loc`, downhill from here on in.\r\n\r\n            if (bestLocation <= expectedLocation) {\r\n              break;\r\n            } // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\r\n\r\n\r\n            start = Math.max(1, 2 * expectedLocation - bestLocation);\r\n          }\r\n        }\r\n      } // No hope for a (better) match at greater error levels.\r\n\r\n\r\n      var _score = computeScore(pattern, {\r\n        errors: _i + 1,\r\n        currentLocation: expectedLocation,\r\n        expectedLocation: expectedLocation,\r\n        distance: distance,\r\n        ignoreLocation: ignoreLocation\r\n      });\r\n\r\n      if (_score > currentThreshold) {\r\n        break;\r\n      }\r\n\r\n      lastBitArr = bitArr;\r\n    }\r\n\r\n    var result = {\r\n      isMatch: bestLocation >= 0,\r\n      // Count exact matches (those with a score of 0) to be \"almost\" exact\r\n      score: Math.max(0.001, finalScore)\r\n    };\r\n\r\n    if (computeMatches) {\r\n      var indices = convertMaskToIndices(matchMask, minMatchCharLength);\r\n\r\n      if (!indices.length) {\r\n        result.isMatch = false;\r\n      } else if (includeMatches) {\r\n        result.indices = indices;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  function createPatternAlphabet(pattern) {\r\n    var mask = {};\r\n\r\n    for (var i = 0, len = pattern.length; i < len; i += 1) {\r\n      var char = pattern.charAt(i);\r\n      mask[char] = (mask[char] || 0) | 1 << len - i - 1;\r\n    }\r\n\r\n    return mask;\r\n  }\r\n\r\n  var BitapSearch = /*#__PURE__*/function () {\r\n    function BitapSearch(pattern) {\r\n      var _this = this;\r\n\r\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\r\n          _ref$location = _ref.location,\r\n          location = _ref$location === void 0 ? Config.location : _ref$location,\r\n          _ref$threshold = _ref.threshold,\r\n          threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,\r\n          _ref$distance = _ref.distance,\r\n          distance = _ref$distance === void 0 ? Config.distance : _ref$distance,\r\n          _ref$includeMatches = _ref.includeMatches,\r\n          includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,\r\n          _ref$findAllMatches = _ref.findAllMatches,\r\n          findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,\r\n          _ref$minMatchCharLeng = _ref.minMatchCharLength,\r\n          minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,\r\n          _ref$isCaseSensitive = _ref.isCaseSensitive,\r\n          isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,\r\n          _ref$ignoreLocation = _ref.ignoreLocation,\r\n          ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;\r\n\r\n      _classCallCheck(this, BitapSearch);\r\n\r\n      this.options = {\r\n        location: location,\r\n        threshold: threshold,\r\n        distance: distance,\r\n        includeMatches: includeMatches,\r\n        findAllMatches: findAllMatches,\r\n        minMatchCharLength: minMatchCharLength,\r\n        isCaseSensitive: isCaseSensitive,\r\n        ignoreLocation: ignoreLocation\r\n      };\r\n      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\r\n      this.chunks = [];\r\n\r\n      if (!this.pattern.length) {\r\n        return;\r\n      }\r\n\r\n      var addChunk = function addChunk(pattern, startIndex) {\r\n        _this.chunks.push({\r\n          pattern: pattern,\r\n          alphabet: createPatternAlphabet(pattern),\r\n          startIndex: startIndex\r\n        });\r\n      };\r\n\r\n      var len = this.pattern.length;\r\n\r\n      if (len > MAX_BITS) {\r\n        var i = 0;\r\n        var remainder = len % MAX_BITS;\r\n        var end = len - remainder;\r\n\r\n        while (i < end) {\r\n          addChunk(this.pattern.substr(i, MAX_BITS), i);\r\n          i += MAX_BITS;\r\n        }\r\n\r\n        if (remainder) {\r\n          var startIndex = len - MAX_BITS;\r\n          addChunk(this.pattern.substr(startIndex), startIndex);\r\n        }\r\n      } else {\r\n        addChunk(this.pattern, 0);\r\n      }\r\n    }\r\n\r\n    _createClass(BitapSearch, [{\r\n      key: \"searchIn\",\r\n      value: function searchIn(text) {\r\n        var _this$options = this.options,\r\n            isCaseSensitive = _this$options.isCaseSensitive,\r\n            includeMatches = _this$options.includeMatches;\r\n\r\n        if (!isCaseSensitive) {\r\n          text = text.toLowerCase();\r\n        } // Exact match\r\n\r\n\r\n        if (this.pattern === text) {\r\n          var _result = {\r\n            isMatch: true,\r\n            score: 0\r\n          };\r\n\r\n          if (includeMatches) {\r\n            _result.indices = [[0, text.length - 1]];\r\n          }\r\n\r\n          return _result;\r\n        } // Otherwise, use Bitap algorithm\r\n\r\n\r\n        var _this$options2 = this.options,\r\n            location = _this$options2.location,\r\n            distance = _this$options2.distance,\r\n            threshold = _this$options2.threshold,\r\n            findAllMatches = _this$options2.findAllMatches,\r\n            minMatchCharLength = _this$options2.minMatchCharLength,\r\n            ignoreLocation = _this$options2.ignoreLocation;\r\n        var allIndices = [];\r\n        var totalScore = 0;\r\n        var hasMatches = false;\r\n        this.chunks.forEach(function (_ref2) {\r\n          var pattern = _ref2.pattern,\r\n              alphabet = _ref2.alphabet,\r\n              startIndex = _ref2.startIndex;\r\n\r\n          var _search = search(text, pattern, alphabet, {\r\n            location: location + startIndex,\r\n            distance: distance,\r\n            threshold: threshold,\r\n            findAllMatches: findAllMatches,\r\n            minMatchCharLength: minMatchCharLength,\r\n            includeMatches: includeMatches,\r\n            ignoreLocation: ignoreLocation\r\n          }),\r\n              isMatch = _search.isMatch,\r\n              score = _search.score,\r\n              indices = _search.indices;\r\n\r\n          if (isMatch) {\r\n            hasMatches = true;\r\n          }\r\n\r\n          totalScore += score;\r\n\r\n          if (isMatch && indices) {\r\n            allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));\r\n          }\r\n        });\r\n        var result = {\r\n          isMatch: hasMatches,\r\n          score: hasMatches ? totalScore / this.chunks.length : 1\r\n        };\r\n\r\n        if (hasMatches && includeMatches) {\r\n          result.indices = allIndices;\r\n        }\r\n\r\n        return result;\r\n      }\r\n    }]);\r\n\r\n    return BitapSearch;\r\n  }();\r\n\r\n  var BaseMatch = /*#__PURE__*/function () {\r\n    function BaseMatch(pattern) {\r\n      _classCallCheck(this, BaseMatch);\r\n\r\n      this.pattern = pattern;\r\n    }\r\n\r\n    _createClass(BaseMatch, [{\r\n      key: \"search\",\r\n      value: function search()\r\n      /*text*/\r\n      {}\r\n    }], [{\r\n      key: \"isMultiMatch\",\r\n      value: function isMultiMatch(pattern) {\r\n        return getMatch(pattern, this.multiRegex);\r\n      }\r\n    }, {\r\n      key: \"isSingleMatch\",\r\n      value: function isSingleMatch(pattern) {\r\n        return getMatch(pattern, this.singleRegex);\r\n      }\r\n    }]);\r\n\r\n    return BaseMatch;\r\n  }();\r\n\r\n  function getMatch(pattern, exp) {\r\n    var matches = pattern.match(exp);\r\n    return matches ? matches[1] : null;\r\n  }\r\n\r\n  var ExactMatch = /*#__PURE__*/function (_BaseMatch) {\r\n    _inherits(ExactMatch, _BaseMatch);\r\n\r\n    var _super = _createSuper(ExactMatch);\r\n\r\n    function ExactMatch(pattern) {\r\n      _classCallCheck(this, ExactMatch);\r\n\r\n      return _super.call(this, pattern);\r\n    }\r\n\r\n    _createClass(ExactMatch, [{\r\n      key: \"search\",\r\n      value: function search(text) {\r\n        var isMatch = text === this.pattern;\r\n        return {\r\n          isMatch: isMatch,\r\n          score: isMatch ? 0 : 1,\r\n          indices: [0, this.pattern.length - 1]\r\n        };\r\n      }\r\n    }], [{\r\n      key: \"type\",\r\n      get: function get() {\r\n        return 'exact';\r\n      }\r\n    }, {\r\n      key: \"multiRegex\",\r\n      get: function get() {\r\n        return /^=\"(.*)\"$/;\r\n      }\r\n    }, {\r\n      key: \"singleRegex\",\r\n      get: function get() {\r\n        return /^=(.*)$/;\r\n      }\r\n    }]);\r\n\r\n    return ExactMatch;\r\n  }(BaseMatch);\r\n\r\n  var InverseExactMatch = /*#__PURE__*/function (_BaseMatch) {\r\n    _inherits(InverseExactMatch, _BaseMatch);\r\n\r\n    var _super = _createSuper(InverseExactMatch);\r\n\r\n    function InverseExactMatch(pattern) {\r\n      _classCallCheck(this, InverseExactMatch);\r\n\r\n      return _super.call(this, pattern);\r\n    }\r\n\r\n    _createClass(InverseExactMatch, [{\r\n      key: \"search\",\r\n      value: function search(text) {\r\n        var index = text.indexOf(this.pattern);\r\n        var isMatch = index === -1;\r\n        return {\r\n          isMatch: isMatch,\r\n          score: isMatch ? 0 : 1,\r\n          indices: [0, text.length - 1]\r\n        };\r\n      }\r\n    }], [{\r\n      key: \"type\",\r\n      get: function get() {\r\n        return 'inverse-exact';\r\n      }\r\n    }, {\r\n      key: \"multiRegex\",\r\n      get: function get() {\r\n        return /^!\"(.*)\"$/;\r\n      }\r\n    }, {\r\n      key: \"singleRegex\",\r\n      get: function get() {\r\n        return /^!(.*)$/;\r\n      }\r\n    }]);\r\n\r\n    return InverseExactMatch;\r\n  }(BaseMatch);\r\n\r\n  var PrefixExactMatch = /*#__PURE__*/function (_BaseMatch) {\r\n    _inherits(PrefixExactMatch, _BaseMatch);\r\n\r\n    var _super = _createSuper(PrefixExactMatch);\r\n\r\n    function PrefixExactMatch(pattern) {\r\n      _classCallCheck(this, PrefixExactMatch);\r\n\r\n      return _super.call(this, pattern);\r\n    }\r\n\r\n    _createClass(PrefixExactMatch, [{\r\n      key: \"search\",\r\n      value: function search(text) {\r\n        var isMatch = text.startsWith(this.pattern);\r\n        return {\r\n          isMatch: isMatch,\r\n          score: isMatch ? 0 : 1,\r\n          indices: [0, this.pattern.length - 1]\r\n        };\r\n      }\r\n    }], [{\r\n      key: \"type\",\r\n      get: function get() {\r\n        return 'prefix-exact';\r\n      }\r\n    }, {\r\n      key: \"multiRegex\",\r\n      get: function get() {\r\n        return /^\\^\"(.*)\"$/;\r\n      }\r\n    }, {\r\n      key: \"singleRegex\",\r\n      get: function get() {\r\n        return /^\\^(.*)$/;\r\n      }\r\n    }]);\r\n\r\n    return PrefixExactMatch;\r\n  }(BaseMatch);\r\n\r\n  var InversePrefixExactMatch = /*#__PURE__*/function (_BaseMatch) {\r\n    _inherits(InversePrefixExactMatch, _BaseMatch);\r\n\r\n    var _super = _createSuper(InversePrefixExactMatch);\r\n\r\n    function InversePrefixExactMatch(pattern) {\r\n      _classCallCheck(this, InversePrefixExactMatch);\r\n\r\n      return _super.call(this, pattern);\r\n    }\r\n\r\n    _createClass(InversePrefixExactMatch, [{\r\n      key: \"search\",\r\n      value: function search(text) {\r\n        var isMatch = !text.startsWith(this.pattern);\r\n        return {\r\n          isMatch: isMatch,\r\n          score: isMatch ? 0 : 1,\r\n          indices: [0, text.length - 1]\r\n        };\r\n      }\r\n    }], [{\r\n      key: \"type\",\r\n      get: function get() {\r\n        return 'inverse-prefix-exact';\r\n      }\r\n    }, {\r\n      key: \"multiRegex\",\r\n      get: function get() {\r\n        return /^!\\^\"(.*)\"$/;\r\n      }\r\n    }, {\r\n      key: \"singleRegex\",\r\n      get: function get() {\r\n        return /^!\\^(.*)$/;\r\n      }\r\n    }]);\r\n\r\n    return InversePrefixExactMatch;\r\n  }(BaseMatch);\r\n\r\n  var SuffixExactMatch = /*#__PURE__*/function (_BaseMatch) {\r\n    _inherits(SuffixExactMatch, _BaseMatch);\r\n\r\n    var _super = _createSuper(SuffixExactMatch);\r\n\r\n    function SuffixExactMatch(pattern) {\r\n      _classCallCheck(this, SuffixExactMatch);\r\n\r\n      return _super.call(this, pattern);\r\n    }\r\n\r\n    _createClass(SuffixExactMatch, [{\r\n      key: \"search\",\r\n      value: function search(text) {\r\n        var isMatch = text.endsWith(this.pattern);\r\n        return {\r\n          isMatch: isMatch,\r\n          score: isMatch ? 0 : 1,\r\n          indices: [text.length - this.pattern.length, text.length - 1]\r\n        };\r\n      }\r\n    }], [{\r\n      key: \"type\",\r\n      get: function get() {\r\n        return 'suffix-exact';\r\n      }\r\n    }, {\r\n      key: \"multiRegex\",\r\n      get: function get() {\r\n        return /^\"(.*)\"\\$$/;\r\n      }\r\n    }, {\r\n      key: \"singleRegex\",\r\n      get: function get() {\r\n        return /^(.*)\\$$/;\r\n      }\r\n    }]);\r\n\r\n    return SuffixExactMatch;\r\n  }(BaseMatch);\r\n\r\n  var InverseSuffixExactMatch = /*#__PURE__*/function (_BaseMatch) {\r\n    _inherits(InverseSuffixExactMatch, _BaseMatch);\r\n\r\n    var _super = _createSuper(InverseSuffixExactMatch);\r\n\r\n    function InverseSuffixExactMatch(pattern) {\r\n      _classCallCheck(this, InverseSuffixExactMatch);\r\n\r\n      return _super.call(this, pattern);\r\n    }\r\n\r\n    _createClass(InverseSuffixExactMatch, [{\r\n      key: \"search\",\r\n      value: function search(text) {\r\n        var isMatch = !text.endsWith(this.pattern);\r\n        return {\r\n          isMatch: isMatch,\r\n          score: isMatch ? 0 : 1,\r\n          indices: [0, text.length - 1]\r\n        };\r\n      }\r\n    }], [{\r\n      key: \"type\",\r\n      get: function get() {\r\n        return 'inverse-suffix-exact';\r\n      }\r\n    }, {\r\n      key: \"multiRegex\",\r\n      get: function get() {\r\n        return /^!\"(.*)\"\\$$/;\r\n      }\r\n    }, {\r\n      key: \"singleRegex\",\r\n      get: function get() {\r\n        return /^!(.*)\\$$/;\r\n      }\r\n    }]);\r\n\r\n    return InverseSuffixExactMatch;\r\n  }(BaseMatch);\r\n\r\n  var FuzzyMatch = /*#__PURE__*/function (_BaseMatch) {\r\n    _inherits(FuzzyMatch, _BaseMatch);\r\n\r\n    var _super = _createSuper(FuzzyMatch);\r\n\r\n    function FuzzyMatch(pattern) {\r\n      var _this;\r\n\r\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\r\n          _ref$location = _ref.location,\r\n          location = _ref$location === void 0 ? Config.location : _ref$location,\r\n          _ref$threshold = _ref.threshold,\r\n          threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,\r\n          _ref$distance = _ref.distance,\r\n          distance = _ref$distance === void 0 ? Config.distance : _ref$distance,\r\n          _ref$includeMatches = _ref.includeMatches,\r\n          includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,\r\n          _ref$findAllMatches = _ref.findAllMatches,\r\n          findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,\r\n          _ref$minMatchCharLeng = _ref.minMatchCharLength,\r\n          minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,\r\n          _ref$isCaseSensitive = _ref.isCaseSensitive,\r\n          isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,\r\n          _ref$ignoreLocation = _ref.ignoreLocation,\r\n          ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;\r\n\r\n      _classCallCheck(this, FuzzyMatch);\r\n\r\n      _this = _super.call(this, pattern);\r\n      _this._bitapSearch = new BitapSearch(pattern, {\r\n        location: location,\r\n        threshold: threshold,\r\n        distance: distance,\r\n        includeMatches: includeMatches,\r\n        findAllMatches: findAllMatches,\r\n        minMatchCharLength: minMatchCharLength,\r\n        isCaseSensitive: isCaseSensitive,\r\n        ignoreLocation: ignoreLocation\r\n      });\r\n      return _this;\r\n    }\r\n\r\n    _createClass(FuzzyMatch, [{\r\n      key: \"search\",\r\n      value: function search(text) {\r\n        return this._bitapSearch.searchIn(text);\r\n      }\r\n    }], [{\r\n      key: \"type\",\r\n      get: function get() {\r\n        return 'fuzzy';\r\n      }\r\n    }, {\r\n      key: \"multiRegex\",\r\n      get: function get() {\r\n        return /^\"(.*)\"$/;\r\n      }\r\n    }, {\r\n      key: \"singleRegex\",\r\n      get: function get() {\r\n        return /^(.*)$/;\r\n      }\r\n    }]);\r\n\r\n    return FuzzyMatch;\r\n  }(BaseMatch);\r\n\r\n  var IncludeMatch = /*#__PURE__*/function (_BaseMatch) {\r\n    _inherits(IncludeMatch, _BaseMatch);\r\n\r\n    var _super = _createSuper(IncludeMatch);\r\n\r\n    function IncludeMatch(pattern) {\r\n      _classCallCheck(this, IncludeMatch);\r\n\r\n      return _super.call(this, pattern);\r\n    }\r\n\r\n    _createClass(IncludeMatch, [{\r\n      key: \"search\",\r\n      value: function search(text) {\r\n        var location = 0;\r\n        var index;\r\n        var indices = [];\r\n        var patternLen = this.pattern.length; // Get all exact matches\r\n\r\n        while ((index = text.indexOf(this.pattern, location)) > -1) {\r\n          location = index + patternLen;\r\n          indices.push([index, location - 1]);\r\n        }\r\n\r\n        var isMatch = !!indices.length;\r\n        return {\r\n          isMatch: isMatch,\r\n          score: isMatch ? 0 : 1,\r\n          indices: indices\r\n        };\r\n      }\r\n    }], [{\r\n      key: \"type\",\r\n      get: function get() {\r\n        return 'include';\r\n      }\r\n    }, {\r\n      key: \"multiRegex\",\r\n      get: function get() {\r\n        return /^'\"(.*)\"$/;\r\n      }\r\n    }, {\r\n      key: \"singleRegex\",\r\n      get: function get() {\r\n        return /^'(.*)$/;\r\n      }\r\n    }]);\r\n\r\n    return IncludeMatch;\r\n  }(BaseMatch);\r\n\r\n  var searchers = [ExactMatch, IncludeMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch];\r\n  var searchersLen = searchers.length; // Regex to split by spaces, but keep anything in quotes together\r\n\r\n  var SPACE_RE = / +(?=([^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\r\n  var OR_TOKEN = '|'; // Return a 2D array representation of the query, for simpler parsing.\r\n  // Example:\r\n  // \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\r\n\r\n  function parseQuery(pattern) {\r\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n    return pattern.split(OR_TOKEN).map(function (item) {\r\n      var query = item.trim().split(SPACE_RE).filter(function (item) {\r\n        return item && !!item.trim();\r\n      });\r\n      var results = [];\r\n\r\n      for (var i = 0, len = query.length; i < len; i += 1) {\r\n        var queryItem = query[i]; // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\r\n\r\n        var found = false;\r\n        var idx = -1;\r\n\r\n        while (!found && ++idx < searchersLen) {\r\n          var searcher = searchers[idx];\r\n          var token = searcher.isMultiMatch(queryItem);\r\n\r\n          if (token) {\r\n            results.push(new searcher(token, options));\r\n            found = true;\r\n          }\r\n        }\r\n\r\n        if (found) {\r\n          continue;\r\n        } // 2. Handle single query matches (i.e, once that are *not* quoted)\r\n\r\n\r\n        idx = -1;\r\n\r\n        while (++idx < searchersLen) {\r\n          var _searcher = searchers[idx];\r\n\r\n          var _token = _searcher.isSingleMatch(queryItem);\r\n\r\n          if (_token) {\r\n            results.push(new _searcher(_token, options));\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return results;\r\n    });\r\n  }\r\n\r\n  // to a singl match\r\n\r\n  var MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);\r\n  /**\r\n   * Command-like searching\r\n   * ======================\r\n   *\r\n   * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\r\n   * search in a given text.\r\n   *\r\n   * Search syntax:\r\n   *\r\n   * | Token       | Match type                 | Description                            |\r\n   * | ----------- | -------------------------- | -------------------------------------- |\r\n   * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\r\n   * | `=scheme`   | exact-match                | Items that are `scheme`                |\r\n   * | `'python`   | include-match              | Items that include `python`            |\r\n   * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\r\n   * | `^java`     | prefix-exact-match         | Items that start with `java`           |\r\n   * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\r\n   * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\r\n   * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\r\n   *\r\n   * A single pipe character acts as an OR operator. For example, the following\r\n   * query matches entries that start with `core` and end with either`go`, `rb`,\r\n   * or`py`.\r\n   *\r\n   * ```\r\n   * ^core go$ | rb$ | py$\r\n   * ```\r\n   */\r\n\r\n  var ExtendedSearch = /*#__PURE__*/function () {\r\n    function ExtendedSearch(pattern) {\r\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\r\n          _ref$isCaseSensitive = _ref.isCaseSensitive,\r\n          isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,\r\n          _ref$includeMatches = _ref.includeMatches,\r\n          includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,\r\n          _ref$minMatchCharLeng = _ref.minMatchCharLength,\r\n          minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,\r\n          _ref$ignoreLocation = _ref.ignoreLocation,\r\n          ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation,\r\n          _ref$findAllMatches = _ref.findAllMatches,\r\n          findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,\r\n          _ref$location = _ref.location,\r\n          location = _ref$location === void 0 ? Config.location : _ref$location,\r\n          _ref$threshold = _ref.threshold,\r\n          threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,\r\n          _ref$distance = _ref.distance,\r\n          distance = _ref$distance === void 0 ? Config.distance : _ref$distance;\r\n\r\n      _classCallCheck(this, ExtendedSearch);\r\n\r\n      this.query = null;\r\n      this.options = {\r\n        isCaseSensitive: isCaseSensitive,\r\n        includeMatches: includeMatches,\r\n        minMatchCharLength: minMatchCharLength,\r\n        findAllMatches: findAllMatches,\r\n        ignoreLocation: ignoreLocation,\r\n        location: location,\r\n        threshold: threshold,\r\n        distance: distance\r\n      };\r\n      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\r\n      this.query = parseQuery(this.pattern, this.options);\r\n    }\r\n\r\n    _createClass(ExtendedSearch, [{\r\n      key: \"searchIn\",\r\n      value: function searchIn(text) {\r\n        var query = this.query;\r\n\r\n        if (!query) {\r\n          return {\r\n            isMatch: false,\r\n            score: 1\r\n          };\r\n        }\r\n\r\n        var _this$options = this.options,\r\n            includeMatches = _this$options.includeMatches,\r\n            isCaseSensitive = _this$options.isCaseSensitive;\r\n        text = isCaseSensitive ? text : text.toLowerCase();\r\n        var numMatches = 0;\r\n        var allIndices = [];\r\n        var totalScore = 0; // ORs\r\n\r\n        for (var i = 0, qLen = query.length; i < qLen; i += 1) {\r\n          var searchers = query[i]; // Reset indices\r\n\r\n          allIndices.length = 0;\r\n          numMatches = 0; // ANDs\r\n\r\n          for (var j = 0, pLen = searchers.length; j < pLen; j += 1) {\r\n            var searcher = searchers[j];\r\n\r\n            var _searcher$search = searcher.search(text),\r\n                isMatch = _searcher$search.isMatch,\r\n                indices = _searcher$search.indices,\r\n                score = _searcher$search.score;\r\n\r\n            if (isMatch) {\r\n              numMatches += 1;\r\n              totalScore += score;\r\n\r\n              if (includeMatches) {\r\n                var type = searcher.constructor.type;\r\n\r\n                if (MultiMatchSet.has(type)) {\r\n                  allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));\r\n                } else {\r\n                  allIndices.push(indices);\r\n                }\r\n              }\r\n            } else {\r\n              totalScore = 0;\r\n              numMatches = 0;\r\n              allIndices.length = 0;\r\n              break;\r\n            }\r\n          } // OR condition, so if TRUE, return\r\n\r\n\r\n          if (numMatches) {\r\n            var result = {\r\n              isMatch: true,\r\n              score: totalScore / numMatches\r\n            };\r\n\r\n            if (includeMatches) {\r\n              result.indices = allIndices;\r\n            }\r\n\r\n            return result;\r\n          }\r\n        } // Nothing was matched\r\n\r\n\r\n        return {\r\n          isMatch: false,\r\n          score: 1\r\n        };\r\n      }\r\n    }], [{\r\n      key: \"condition\",\r\n      value: function condition(_, options) {\r\n        return options.useExtendedSearch;\r\n      }\r\n    }]);\r\n\r\n    return ExtendedSearch;\r\n  }();\r\n\r\n  var registeredSearchers = [];\r\n  function register() {\r\n    registeredSearchers.push.apply(registeredSearchers, arguments);\r\n  }\r\n  function createSearcher(pattern, options) {\r\n    for (var i = 0, len = registeredSearchers.length; i < len; i += 1) {\r\n      var searcherClass = registeredSearchers[i];\r\n\r\n      if (searcherClass.condition(pattern, options)) {\r\n        return new searcherClass(pattern, options);\r\n      }\r\n    }\r\n\r\n    return new BitapSearch(pattern, options);\r\n  }\r\n\r\n  var LogicalOperator = {\r\n    AND: '$and',\r\n    OR: '$or'\r\n  };\r\n  var KeyType = {\r\n    PATH: '$path',\r\n    PATTERN: '$val'\r\n  };\r\n\r\n  var isExpression = function isExpression(query) {\r\n    return !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\r\n  };\r\n\r\n  var isPath = function isPath(query) {\r\n    return !!query[KeyType.PATH];\r\n  };\r\n\r\n  var isLeaf = function isLeaf(query) {\r\n    return !isArray(query) && isObject(query) && !isExpression(query);\r\n  };\r\n\r\n  var convertToExplicit = function convertToExplicit(query) {\r\n    return _defineProperty({}, LogicalOperator.AND, Object.keys(query).map(function (key) {\r\n      return _defineProperty({}, key, query[key]);\r\n    }));\r\n  }; // When `auto` is `true`, the parse function will infer and initialize and add\r\n  // the appropriate `Searcher` instance\r\n\r\n\r\n  function parse(query, options) {\r\n    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\r\n        _ref3$auto = _ref3.auto,\r\n        auto = _ref3$auto === void 0 ? true : _ref3$auto;\r\n\r\n    var next = function next(query) {\r\n      var keys = Object.keys(query);\r\n      var isQueryPath = isPath(query);\r\n\r\n      if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\r\n        return next(convertToExplicit(query));\r\n      }\r\n\r\n      if (isLeaf(query)) {\r\n        var key = isQueryPath ? query[KeyType.PATH] : keys[0];\r\n        var pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\r\n\r\n        if (!isString(pattern)) {\r\n          throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));\r\n        }\r\n\r\n        var obj = {\r\n          keyId: createKeyId(key),\r\n          pattern: pattern\r\n        };\r\n\r\n        if (auto) {\r\n          obj.searcher = createSearcher(pattern, options);\r\n        }\r\n\r\n        return obj;\r\n      }\r\n\r\n      var node = {\r\n        children: [],\r\n        operator: keys[0]\r\n      };\r\n      keys.forEach(function (key) {\r\n        var value = query[key];\r\n\r\n        if (isArray(value)) {\r\n          value.forEach(function (item) {\r\n            node.children.push(next(item));\r\n          });\r\n        }\r\n      });\r\n      return node;\r\n    };\r\n\r\n    if (!isExpression(query)) {\r\n      query = convertToExplicit(query);\r\n    }\r\n\r\n    return next(query);\r\n  }\r\n\r\n  function computeScore$1(results, _ref) {\r\n    var _ref$ignoreFieldNorm = _ref.ignoreFieldNorm,\r\n        ignoreFieldNorm = _ref$ignoreFieldNorm === void 0 ? Config.ignoreFieldNorm : _ref$ignoreFieldNorm;\r\n    results.forEach(function (result) {\r\n      var totalScore = 1;\r\n      result.matches.forEach(function (_ref2) {\r\n        var key = _ref2.key,\r\n            norm = _ref2.norm,\r\n            score = _ref2.score;\r\n        var weight = key ? key.weight : null;\r\n        totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm));\r\n      });\r\n      result.score = totalScore;\r\n    });\r\n  }\r\n\r\n  function transformMatches(result, data) {\r\n    var matches = result.matches;\r\n    data.matches = [];\r\n\r\n    if (!isDefined(matches)) {\r\n      return;\r\n    }\r\n\r\n    matches.forEach(function (match) {\r\n      if (!isDefined(match.indices) || !match.indices.length) {\r\n        return;\r\n      }\r\n\r\n      var indices = match.indices,\r\n          value = match.value;\r\n      var obj = {\r\n        indices: indices,\r\n        value: value\r\n      };\r\n\r\n      if (match.key) {\r\n        obj.key = match.key.src;\r\n      }\r\n\r\n      if (match.idx > -1) {\r\n        obj.refIndex = match.idx;\r\n      }\r\n\r\n      data.matches.push(obj);\r\n    });\r\n  }\r\n\r\n  function transformScore(result, data) {\r\n    data.score = result.score;\r\n  }\r\n\r\n  function format(results, docs) {\r\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\r\n        _ref$includeMatches = _ref.includeMatches,\r\n        includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,\r\n        _ref$includeScore = _ref.includeScore,\r\n        includeScore = _ref$includeScore === void 0 ? Config.includeScore : _ref$includeScore;\r\n\r\n    var transformers = [];\r\n    if (includeMatches) transformers.push(transformMatches);\r\n    if (includeScore) transformers.push(transformScore);\r\n    return results.map(function (result) {\r\n      var idx = result.idx;\r\n      var data = {\r\n        item: docs[idx],\r\n        refIndex: idx\r\n      };\r\n\r\n      if (transformers.length) {\r\n        transformers.forEach(function (transformer) {\r\n          transformer(result, data);\r\n        });\r\n      }\r\n\r\n      return data;\r\n    });\r\n  }\r\n\r\n  var Fuse = /*#__PURE__*/function () {\r\n    function Fuse(docs) {\r\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n      var index = arguments.length > 2 ? arguments[2] : undefined;\r\n\r\n      _classCallCheck(this, Fuse);\r\n\r\n      this.options = _objectSpread2({}, Config, {}, options);\r\n\r\n      if (this.options.useExtendedSearch && !true) {\r\n        throw new Error(EXTENDED_SEARCH_UNAVAILABLE);\r\n      }\r\n\r\n      this._keyStore = new KeyStore(this.options.keys);\r\n      this.setCollection(docs, index);\r\n    }\r\n\r\n    _createClass(Fuse, [{\r\n      key: \"setCollection\",\r\n      value: function setCollection(docs, index) {\r\n        this._docs = docs;\r\n\r\n        if (index && !(index instanceof FuseIndex)) {\r\n          throw new Error(INCORRECT_INDEX_TYPE);\r\n        }\r\n\r\n        this._myIndex = index || createIndex(this.options.keys, this._docs, {\r\n          getFn: this.options.getFn\r\n        });\r\n      }\r\n    }, {\r\n      key: \"add\",\r\n      value: function add(doc) {\r\n        if (!isDefined(doc)) {\r\n          return;\r\n        }\r\n\r\n        this._docs.push(doc);\r\n\r\n        this._myIndex.add(doc);\r\n      }\r\n    }, {\r\n      key: \"remove\",\r\n      value: function remove() {\r\n        var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\r\n          return (\r\n            /* doc, idx */\r\n            false\r\n          );\r\n        };\r\n        var results = [];\r\n\r\n        for (var i = 0, len = this._docs.length; i < len; i += 1) {\r\n          var doc = this._docs[i];\r\n\r\n          if (predicate(doc, i)) {\r\n            this.removeAt(i);\r\n            i -= 1;\r\n            len -= 1;\r\n            results.push(doc);\r\n          }\r\n        }\r\n\r\n        return results;\r\n      }\r\n    }, {\r\n      key: \"removeAt\",\r\n      value: function removeAt(idx) {\r\n        this._docs.splice(idx, 1);\r\n\r\n        this._myIndex.removeAt(idx);\r\n      }\r\n    }, {\r\n      key: \"getIndex\",\r\n      value: function getIndex() {\r\n        return this._myIndex;\r\n      }\r\n    }, {\r\n      key: \"search\",\r\n      value: function search(query) {\r\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\r\n            _ref$limit = _ref.limit,\r\n            limit = _ref$limit === void 0 ? -1 : _ref$limit;\r\n\r\n        var _this$options = this.options,\r\n            includeMatches = _this$options.includeMatches,\r\n            includeScore = _this$options.includeScore,\r\n            shouldSort = _this$options.shouldSort,\r\n            sortFn = _this$options.sortFn,\r\n            ignoreFieldNorm = _this$options.ignoreFieldNorm;\r\n        var results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);\r\n        computeScore$1(results, {\r\n          ignoreFieldNorm: ignoreFieldNorm\r\n        });\r\n\r\n        if (shouldSort) {\r\n          results.sort(sortFn);\r\n        }\r\n\r\n        if (isNumber(limit) && limit > -1) {\r\n          results = results.slice(0, limit);\r\n        }\r\n\r\n        return format(results, this._docs, {\r\n          includeMatches: includeMatches,\r\n          includeScore: includeScore\r\n        });\r\n      }\r\n    }, {\r\n      key: \"_searchStringList\",\r\n      value: function _searchStringList(query) {\r\n        var searcher = createSearcher(query, this.options);\r\n        var records = this._myIndex.records;\r\n        var results = []; // Iterate over every string in the index\r\n\r\n        records.forEach(function (_ref2) {\r\n          var text = _ref2.v,\r\n              idx = _ref2.i,\r\n              norm = _ref2.n;\r\n\r\n          if (!isDefined(text)) {\r\n            return;\r\n          }\r\n\r\n          var _searcher$searchIn = searcher.searchIn(text),\r\n              isMatch = _searcher$searchIn.isMatch,\r\n              score = _searcher$searchIn.score,\r\n              indices = _searcher$searchIn.indices;\r\n\r\n          if (isMatch) {\r\n            results.push({\r\n              item: text,\r\n              idx: idx,\r\n              matches: [{\r\n                score: score,\r\n                value: text,\r\n                norm: norm,\r\n                indices: indices\r\n              }]\r\n            });\r\n          }\r\n        });\r\n        return results;\r\n      }\r\n    }, {\r\n      key: \"_searchLogical\",\r\n      value: function _searchLogical(query) {\r\n        var _this = this;\r\n\r\n        var expression = parse(query, this.options);\r\n\r\n        var evaluate = function evaluate(node, item, idx) {\r\n          if (!node.children) {\r\n            var keyId = node.keyId,\r\n                searcher = node.searcher;\r\n\r\n            var matches = _this._findMatches({\r\n              key: _this._keyStore.get(keyId),\r\n              value: _this._myIndex.getValueForItemAtKeyId(item, keyId),\r\n              searcher: searcher\r\n            });\r\n\r\n            if (matches && matches.length) {\r\n              return [{\r\n                idx: idx,\r\n                item: item,\r\n                matches: matches\r\n              }];\r\n            }\r\n\r\n            return [];\r\n          }\r\n          /*eslint indent: [2, 2, {\"SwitchCase\": 1}]*/\r\n\r\n\r\n          switch (node.operator) {\r\n            case LogicalOperator.AND:\r\n              {\r\n                var res = [];\r\n\r\n                for (var i = 0, len = node.children.length; i < len; i += 1) {\r\n                  var child = node.children[i];\r\n                  var result = evaluate(child, item, idx);\r\n\r\n                  if (result.length) {\r\n                    res.push.apply(res, _toConsumableArray(result));\r\n                  } else {\r\n                    return [];\r\n                  }\r\n                }\r\n\r\n                return res;\r\n              }\r\n\r\n            case LogicalOperator.OR:\r\n              {\r\n                var _res = [];\r\n\r\n                for (var _i = 0, _len = node.children.length; _i < _len; _i += 1) {\r\n                  var _child = node.children[_i];\r\n\r\n                  var _result = evaluate(_child, item, idx);\r\n\r\n                  if (_result.length) {\r\n                    _res.push.apply(_res, _toConsumableArray(_result));\r\n\r\n                    break;\r\n                  }\r\n                }\r\n\r\n                return _res;\r\n              }\r\n          }\r\n        };\r\n\r\n        var records = this._myIndex.records;\r\n        var resultMap = {};\r\n        var results = [];\r\n        records.forEach(function (_ref3) {\r\n          var item = _ref3.$,\r\n              idx = _ref3.i;\r\n\r\n          if (isDefined(item)) {\r\n            var expResults = evaluate(expression, item, idx);\r\n\r\n            if (expResults.length) {\r\n              // Dedupe when adding\r\n              if (!resultMap[idx]) {\r\n                resultMap[idx] = {\r\n                  idx: idx,\r\n                  item: item,\r\n                  matches: []\r\n                };\r\n                results.push(resultMap[idx]);\r\n              }\r\n\r\n              expResults.forEach(function (_ref4) {\r\n                var _resultMap$idx$matche;\r\n\r\n                var matches = _ref4.matches;\r\n\r\n                (_resultMap$idx$matche = resultMap[idx].matches).push.apply(_resultMap$idx$matche, _toConsumableArray(matches));\r\n              });\r\n            }\r\n          }\r\n        });\r\n        return results;\r\n      }\r\n    }, {\r\n      key: \"_searchObjectList\",\r\n      value: function _searchObjectList(query) {\r\n        var _this2 = this;\r\n\r\n        var searcher = createSearcher(query, this.options);\r\n        var _this$_myIndex = this._myIndex,\r\n            keys = _this$_myIndex.keys,\r\n            records = _this$_myIndex.records;\r\n        var results = []; // List is Array<Object>\r\n\r\n        records.forEach(function (_ref5) {\r\n          var item = _ref5.$,\r\n              idx = _ref5.i;\r\n\r\n          if (!isDefined(item)) {\r\n            return;\r\n          }\r\n\r\n          var matches = []; // Iterate over every key (i.e, path), and fetch the value at that key\r\n\r\n          keys.forEach(function (key, keyIndex) {\r\n            matches.push.apply(matches, _toConsumableArray(_this2._findMatches({\r\n              key: key,\r\n              value: item[keyIndex],\r\n              searcher: searcher\r\n            })));\r\n          });\r\n\r\n          if (matches.length) {\r\n            results.push({\r\n              idx: idx,\r\n              item: item,\r\n              matches: matches\r\n            });\r\n          }\r\n        });\r\n        return results;\r\n      }\r\n    }, {\r\n      key: \"_findMatches\",\r\n      value: function _findMatches(_ref6) {\r\n        var key = _ref6.key,\r\n            value = _ref6.value,\r\n            searcher = _ref6.searcher;\r\n\r\n        if (!isDefined(value)) {\r\n          return [];\r\n        }\r\n\r\n        var matches = [];\r\n\r\n        if (isArray(value)) {\r\n          value.forEach(function (_ref7) {\r\n            var text = _ref7.v,\r\n                idx = _ref7.i,\r\n                norm = _ref7.n;\r\n\r\n            if (!isDefined(text)) {\r\n              return;\r\n            }\r\n\r\n            var _searcher$searchIn2 = searcher.searchIn(text),\r\n                isMatch = _searcher$searchIn2.isMatch,\r\n                score = _searcher$searchIn2.score,\r\n                indices = _searcher$searchIn2.indices;\r\n\r\n            if (isMatch) {\r\n              matches.push({\r\n                score: score,\r\n                key: key,\r\n                value: text,\r\n                idx: idx,\r\n                norm: norm,\r\n                indices: indices\r\n              });\r\n            }\r\n          });\r\n        } else {\r\n          var text = value.v,\r\n              norm = value.n;\r\n\r\n          var _searcher$searchIn3 = searcher.searchIn(text),\r\n              isMatch = _searcher$searchIn3.isMatch,\r\n              score = _searcher$searchIn3.score,\r\n              indices = _searcher$searchIn3.indices;\r\n\r\n          if (isMatch) {\r\n            matches.push({\r\n              score: score,\r\n              key: key,\r\n              value: text,\r\n              norm: norm,\r\n              indices: indices\r\n            });\r\n          }\r\n        }\r\n\r\n        return matches;\r\n      }\r\n    }]);\r\n\r\n    return Fuse;\r\n  }();\r\n\r\n  Fuse.version = '6.4.6';\r\n  Fuse.createIndex = createIndex;\r\n  Fuse.parseIndex = parseIndex;\r\n  Fuse.config = Config;\r\n\r\n  {\r\n    Fuse.parseQuery = parse;\r\n  }\r\n\r\n  {\r\n    register(ExtendedSearch);\r\n  }\r\n\r\n  return Fuse;\r\n\r\n});\ndefine('skylark-choices/vendors/is-mergeable-object',[],function(){\r\n\tfunction isMergeableObject(value) {\r\n\t\treturn isNonNullObject(value)\r\n\t\t\t&& !isSpecial(value)\r\n\t}\r\n\r\n\tfunction isNonNullObject(value) {\r\n\t\treturn !!value && typeof value === 'object'\r\n\t}\r\n\r\n\tfunction isSpecial(value) {\r\n\t\tvar stringValue = Object.prototype.toString.call(value)\r\n\r\n\t\treturn stringValue === '[object RegExp]'\r\n\t\t\t|| stringValue === '[object Date]'\r\n\t\t\t|| isReactElement(value)\r\n\t}\r\n\r\n\t// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\r\n\tvar canUseSymbol = typeof Symbol === 'function' && Symbol.for\r\n\tvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7\r\n\r\n\tfunction isReactElement(value) {\r\n\t\treturn value.$$typeof === REACT_ELEMENT_TYPE\r\n\t}\r\n\r\n\treturn isMergeableObject;\r\n});\ndefine('skylark-choices/vendors/deepmerge',[\r\n\t\"./is-mergeable-object\"\r\n],function(defaultIsMergeableObject){\r\n\r\n\tfunction emptyTarget(val) {\r\n\t\treturn Array.isArray(val) ? [] : {}\r\n\t}\r\n\r\n\tfunction cloneUnlessOtherwiseSpecified(value, options) {\r\n\t\treturn (options.clone !== false && options.isMergeableObject(value))\r\n\t\t\t? deepmerge(emptyTarget(value), value, options)\r\n\t\t\t: value\r\n\t}\r\n\r\n\tfunction defaultArrayMerge(target, source, options) {\r\n\t\treturn target.concat(source).map(function(element) {\r\n\t\t\treturn cloneUnlessOtherwiseSpecified(element, options)\r\n\t\t})\r\n\t}\r\n\r\n\tfunction getMergeFunction(key, options) {\r\n\t\tif (!options.customMerge) {\r\n\t\t\treturn deepmerge\r\n\t\t}\r\n\t\tvar customMerge = options.customMerge(key)\r\n\t\treturn typeof customMerge === 'function' ? customMerge : deepmerge\r\n\t}\r\n\r\n\tfunction getEnumerableOwnPropertySymbols(target) {\r\n\t\treturn Object.getOwnPropertySymbols\r\n\t\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\r\n\t\t\t\treturn target.propertyIsEnumerable(symbol)\r\n\t\t\t})\r\n\t\t\t: []\r\n\t}\r\n\r\n\tfunction getKeys(target) {\r\n\t\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\r\n\t}\r\n\r\n\tfunction propertyIsOnObject(object, property) {\r\n\t\ttry {\r\n\t\t\treturn property in object\r\n\t\t} catch(_) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\r\n\t// Protects from prototype poisoning and unexpected merging up the prototype chain.\r\n\tfunction propertyIsUnsafe(target, key) {\r\n\t\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\r\n\t\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\r\n\t\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\r\n\t}\r\n\r\n\tfunction mergeObject(target, source, options) {\r\n\t\tvar destination = {}\r\n\t\tif (options.isMergeableObject(target)) {\r\n\t\t\tgetKeys(target).forEach(function(key) {\r\n\t\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options)\r\n\t\t\t})\r\n\t\t}\r\n\t\tgetKeys(source).forEach(function(key) {\r\n\t\t\tif (propertyIsUnsafe(target, key)) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\r\n\t\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options)\r\n\t\t\t} else {\r\n\t\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options)\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn destination\r\n\t}\r\n\r\n\tfunction deepmerge(target, source, options) {\r\n\t\toptions = options || {}\r\n\t\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge\r\n\t\toptions.isMergeableObject = options.isMergeableObject || defaultIsMergeableObject\r\n\t\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\r\n\t\t// implementations can use it. The caller may not replace it.\r\n\t\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified\r\n\r\n\t\tvar sourceIsArray = Array.isArray(source)\r\n\t\tvar targetIsArray = Array.isArray(target)\r\n\t\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray\r\n\r\n\t\tif (!sourceAndTargetTypesMatch) {\r\n\t\t\treturn cloneUnlessOtherwiseSpecified(source, options)\r\n\t\t} else if (sourceIsArray) {\r\n\t\t\treturn options.arrayMerge(target, source, options)\r\n\t\t} else {\r\n\t\t\treturn mergeObject(target, source, options)\r\n\t\t}\r\n\t}\r\n\r\n\tdeepmerge.all = function deepmergeAll(array, options) {\r\n\t\tif (!Array.isArray(array)) {\r\n\t\t\tthrow new Error('first argument should be an array')\r\n\t\t}\r\n\r\n\t\treturn array.reduce(function(prev, next) {\r\n\t\t\treturn deepmerge(prev, next, options)\r\n\t\t}, {})\r\n\t}\r\n\r\n\treturn deepmerge\r\n});\ndefine('skylark-choices/reducers/items',[],function () {\n    'use strict';\n    const defaultState = [];\n    return function items(state = defaultState, action) {\n        switch (action.type) {\n        case 'ADD_ITEM': {\n                const newState = [\n                    ...state,\n                    {\n                        id: action.id,\n                        choiceId: action.choiceId,\n                        groupId: action.groupId,\n                        value: action.value,\n                        label: action.label,\n                        active: true,\n                        highlighted: false,\n                        customProperties: action.customProperties,\n                        placeholder: action.placeholder || false,\n                        keyCode: null\n                    }\n                ];\n                return newState.map(obj => {\n                    const item = obj;\n                    item.highlighted = false;\n                    return item;\n                });\n            }\n        case 'REMOVE_ITEM': {\n                return state.map(obj => {\n                    const item = obj;\n                    if (item.id === action.id) {\n                        item.active = false;\n                    }\n                    return item;\n                });\n            }\n        case 'HIGHLIGHT_ITEM': {\n                return state.map(obj => {\n                    const item = obj;\n                    if (item.id === action.id) {\n                        item.highlighted = action.highlighted;\n                    }\n                    return item;\n                });\n            }\n        default: {\n                return state;\n            }\n        }\n    };\n});\ndefine('skylark-choices/reducers/groups',[],function () {\n    'use strict';\n    const defaultState = [];\n    return function groups(state = defaultState, action) {\n        switch (action.type) {\n        case 'ADD_GROUP': {\n                return [\n                    ...state,\n                    {\n                        id: action.id,\n                        value: action.value,\n                        active: action.active,\n                        disabled: action.disabled\n                    }\n                ];\n            }\n        case 'CLEAR_CHOICES': {\n                return [];\n            }\n        default: {\n                return state;\n            }\n        }\n    };\n});\ndefine('skylark-choices/reducers/choices',[],function () {\n    'use strict';\n    const defaultState = [];\n    return function choices(state = defaultState, action) {\n        switch (action.type) {\n        case 'ADD_CHOICE': {\n                return [\n                    ...state,\n                    {\n                        id: action.id,\n                        elementId: action.elementId,\n                        groupId: action.groupId,\n                        value: action.value,\n                        label: action.label || action.value,\n                        disabled: action.disabled || false,\n                        selected: false,\n                        active: true,\n                        score: 9999,\n                        customProperties: action.customProperties,\n                        placeholder: action.placeholder || false,\n                        keyCode: null\n                    }\n                ];\n            }\n        case 'ADD_ITEM': {\n                if (action.activateOptions) {\n                    return state.map(obj => {\n                        const choice = obj;\n                        choice.active = action.active;\n                        return choice;\n                    });\n                }\n                if (action.choiceId > -1) {\n                    return state.map(obj => {\n                        const choice = obj;\n                        if (choice.id === parseInt(action.choiceId, 10)) {\n                            choice.selected = true;\n                        }\n                        return choice;\n                    });\n                }\n                return state;\n            }\n        case 'REMOVE_ITEM': {\n                if (action.choiceId > -1) {\n                    return state.map(obj => {\n                        const choice = obj;\n                        if (choice.id === parseInt(action.choiceId, 10)) {\n                            choice.selected = false;\n                        }\n                        return choice;\n                    });\n                }\n                return state;\n            }\n        case 'FILTER_CHOICES': {\n                return state.map(obj => {\n                    const choice = obj;\n                    choice.active = action.results.some(({item, score}) => {\n                        if (item.id === choice.id) {\n                            choice.score = score;\n                            return true;\n                        }\n                        return false;\n                    });\n                    return choice;\n                });\n            }\n        case 'ACTIVATE_CHOICES': {\n                return state.map(obj => {\n                    const choice = obj;\n                    choice.active = action.active;\n                    return choice;\n                });\n            }\n        case 'CLEAR_CHOICES': {\n                return defaultState;\n            }\n        default: {\n                return state;\n            }\n        }\n    };\n});\ndefine('skylark-choices/reducers/general',[],function () {\n    'use strict';\n    const defaultState = { loading: false };\n    const general = (state = defaultState, action) => {\n        switch (action.type) {\n        case 'SET_IS_LOADING': {\n                return { loading: action.isLoading };\n            }\n        default: {\n                return state;\n            }\n        }\n    };\n    return general;\n});\ndefine('skylark-choices/lib/utils',[],function () {\n    'use strict';\n    const getRandomNumber = (min, max) => Math.floor(Math.random() * (max - min) + min);\n    const generateChars = length => Array.from({ length }, () => getRandomNumber(0, 36).toString(36)).join('');\n    const generateId = (element, prefix) => {\n        let id = element.id || element.name && `${ element.name }-${ generateChars(2) }` || generateChars(4);\n        id = id.replace(/(:|\\.|\\[|\\]|,)/g, '');\n        id = `${ prefix }-${ id }`;\n        return id;\n    };\n    const getType = obj => Object.prototype.toString.call(obj).slice(8, -1);\n    const isType = (type, obj) => obj !== undefined && obj !== null && getType(obj) === type;\n    const wrap = (element, wrapper = document.createElement('div')) => {\n        if (element.nextSibling) {\n            element.parentNode.insertBefore(wrapper, element.nextSibling);\n        } else {\n            element.parentNode.appendChild(wrapper);\n        }\n        return wrapper.appendChild(element);\n    };\n    const getAdjacentEl = (startEl, selector, direction = 1) => {\n        if (!(startEl instanceof Element) || typeof selector !== 'string') {\n            return undefined;\n        }\n        const prop = `${ direction > 0 ? 'next' : 'previous' }ElementSibling`;\n        let sibling = startEl[prop];\n        while (sibling) {\n            if (sibling.matches(selector)) {\n                return sibling;\n            }\n            sibling = sibling[prop];\n        }\n        return sibling;\n    };\n    const isScrolledIntoView = (element, parent, direction = 1) => {\n        if (!element) {\n            return false;\n        }\n        let isVisible;\n        if (direction > 0) {\n            isVisible = parent.scrollTop + parent.offsetHeight >= element.offsetTop + element.offsetHeight;\n        } else {\n            isVisible = element.offsetTop >= parent.scrollTop;\n        }\n        return isVisible;\n    };\n    const sanitise = value => {\n        if (typeof value !== 'string') {\n            return value;\n        }\n        return value.replace(/&/g, '&amp;').replace(/>/g, '&rt;').replace(/</g, '&lt;').replace(/\"/g, '&quot;');\n    };\n    const strToEl = (() => {\n        const tmpEl = document.createElement('div');\n        return str => {\n            const cleanedInput = str.trim();\n            tmpEl.innerHTML = cleanedInput;\n            const firldChild = tmpEl.children[0];\n            while (tmpEl.firstChild) {\n                tmpEl.removeChild(tmpEl.firstChild);\n            }\n            return firldChild;\n        };\n    })();\n    const sortByAlpha = ({value, label = value}, {\n        value: value2,\n        label: label2 = value2\n    }) => label.localeCompare(label2, [], {\n        sensitivity: 'base',\n        ignorePunctuation: true,\n        numeric: true\n    });\n    const sortByScore = (a, b) => a.score - b.score;\n    const dispatchEvent = (element, type, customArgs = null) => {\n        const event = new CustomEvent(type, {\n            detail: customArgs,\n            bubbles: true,\n            cancelable: true\n        });\n        return element.dispatchEvent(event);\n    };\n    const existsInArray = (array, value, key = 'value') => array.some(item => {\n        if (typeof value === 'string') {\n            return item[key] === value.trim();\n        }\n        return item[key] === value;\n    });\n    const cloneObject = obj => JSON.parse(JSON.stringify(obj));\n    const diff = (a, b) => {\n        const aKeys = Object.keys(a).sort();\n        const bKeys = Object.keys(b).sort();\n        return aKeys.filter(i => bKeys.indexOf(i) < 0);\n    };\n    return {\n        getRandomNumber: getRandomNumber,\n        generateChars: generateChars,\n        generateId: generateId,\n        getType: getType,\n        isType: isType,\n        wrap: wrap,\n        getAdjacentEl: getAdjacentEl,\n        isScrolledIntoView: isScrolledIntoView,\n        sanitise: sanitise,\n        strToEl: strToEl,\n        sortByAlpha: sortByAlpha,\n        sortByScore: sortByScore,\n        dispatchEvent: dispatchEvent,\n        existsInArray: existsInArray,\n        cloneObject: cloneObject,\n        diff: diff\n    };\n});\ndefine('skylark-choices/reducers/index',[\n    'skylark-redux',\n    './items',\n    './groups',\n    './choices',\n    './general',\n    '../lib/utils'\n], function (redux, items, groups, choices, general, utils) {\n    'use strict';\n    const appReducer = redux.combineReducers({\n        items,\n        groups,\n        choices,\n        general\n    });\n    const rootReducer = (passedState, action) => {\n        let state = passedState;\n        if (action.type === 'CLEAR_ALL') {\n            state = undefined;\n        } else if (action.type === 'RESET_TO') {\n            return utils.cloneObject(action.state);\n        }\n        return appReducer(state, action);\n    };\n    return rootReducer;\n});\ndefine('skylark-choices/store/store',[\n    'skylark-redux',\n    '../reducers/index'\n], function (redux, rootReducer) {\n    'use strict';\n    return class Store {\n        constructor() {\n            this._store = redux.createStore(rootReducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());\n        }\n        subscribe(onChange) {\n            this._store.subscribe(onChange);\n        }\n        dispatch(action) {\n            this._store.dispatch(action);\n        }\n        get state() {\n            return this._store.getState();\n        }\n        get items() {\n            return this.state.items;\n        }\n        get activeItems() {\n            return this.items.filter(item => item.active === true);\n        }\n        get highlightedActiveItems() {\n            return this.items.filter(item => item.active && item.highlighted);\n        }\n        get choices() {\n            return this.state.choices;\n        }\n        get activeChoices() {\n            return this.choices.filter(choice => choice.active === true);\n        }\n        get selectableChoices() {\n            return this.choices.filter(choice => choice.disabled !== true);\n        }\n        get searchableChoices() {\n            return this.selectableChoices.filter(choice => choice.placeholder !== true);\n        }\n        get placeholderChoice() {\n            return [...this.choices].reverse().find(choice => choice.placeholder === true);\n        }\n        get groups() {\n            return this.state.groups;\n        }\n        get activeGroups() {\n            const {groups, choices} = this;\n            return groups.filter(group => {\n                const isActive = group.active === true && group.disabled === false;\n                const hasActiveOptions = choices.some(choice => choice.active === true && choice.disabled === false);\n                return isActive && hasActiveOptions;\n            }, []);\n        }\n        isLoading() {\n            return this.state.general.loading;\n        }\n        getChoiceById(id) {\n            return this.activeChoices.find(choice => choice.id === parseInt(id, 10));\n        }\n        getGroupById(id) {\n            return this.groups.find(group => group.id === id);\n        }\n    };\n});\ndefine('skylark-choices/components/dropdown',[],function () {\n    'use strict';\n    return class Dropdown {\n        constructor({element, type, classNames}) {\n            this.element = element;\n            this.classNames = classNames;\n            this.type = type;\n            this.isActive = false;\n        }\n        get distanceFromTopWindow() {\n            return this.element.getBoundingClientRect().bottom;\n        }\n        getChild(selector) {\n            return this.element.querySelector(selector);\n        }\n        show() {\n            this.element.classList.add(this.classNames.activeState);\n            this.element.setAttribute('aria-expanded', 'true');\n            this.isActive = true;\n            return this;\n        }\n        hide() {\n            this.element.classList.remove(this.classNames.activeState);\n            this.element.setAttribute('aria-expanded', 'false');\n            this.isActive = false;\n            return this;\n        }\n    };\n});\ndefine('skylark-choices/constants',['./lib/utils'], function (utils) {\n    'use strict';\n    const DEFAULT_CLASSNAMES = {\n        containerOuter: 'choices',\n        containerInner: 'choices__inner',\n        input: 'choices__input',\n        inputCloned: 'choices__input--cloned',\n        list: 'choices__list',\n        listItems: 'choices__list--multiple',\n        listSingle: 'choices__list--single',\n        listDropdown: 'choices__list--dropdown',\n        item: 'choices__item',\n        itemSelectable: 'choices__item--selectable',\n        itemDisabled: 'choices__item--disabled',\n        itemChoice: 'choices__item--choice',\n        placeholder: 'choices__placeholder',\n        group: 'choices__group',\n        groupHeading: 'choices__heading',\n        button: 'choices__button',\n        activeState: 'is-active',\n        focusState: 'is-focused',\n        openState: 'is-open',\n        disabledState: 'is-disabled',\n        highlightedState: 'is-highlighted',\n        selectedState: 'is-selected',\n        flippedState: 'is-flipped',\n        loadingState: 'is-loading',\n        noResults: 'has-no-results',\n        noChoices: 'has-no-choices'\n    };\n    const DEFAULT_CONFIG = {\n        items: [],\n        choices: [],\n        silent: false,\n        renderChoiceLimit: -1,\n        maxItemCount: -1,\n        addItems: true,\n        addItemFilter: null,\n        removeItems: true,\n        removeItemButton: false,\n        editItems: false,\n        duplicateItemsAllowed: true,\n        delimiter: ',',\n        paste: true,\n        searchEnabled: true,\n        searchChoices: true,\n        searchFloor: 1,\n        searchResultLimit: 4,\n        searchFields: [\n            'label',\n            'value'\n        ],\n        position: 'auto',\n        resetScrollPosition: true,\n        shouldSort: true,\n        shouldSortItems: false,\n        sorter: utils.sortByAlpha,\n        placeholder: true,\n        placeholderValue: null,\n        searchPlaceholderValue: null,\n        prependValue: null,\n        appendValue: null,\n        renderSelectedChoices: 'auto',\n        loadingText: 'Loading...',\n        noResultsText: 'No results found',\n        noChoicesText: 'No choices to choose from',\n        itemSelectText: 'Press to select',\n        uniqueItemText: 'Only unique values can be added',\n        customAddItemText: 'Only values matching specific conditions can be added',\n        addItemText: value => `Press Enter to add <b>\"${ utils.sanitise(value) }\"</b>`,\n        maxItemText: maxItemCount => `Only ${ maxItemCount } values can be added`,\n        valueComparer: (value1, value2) => value1 === value2,\n        fuseOptions: { includeScore: true },\n        callbackOnInit: null,\n        callbackOnCreateTemplates: null,\n        classNames: DEFAULT_CLASSNAMES\n    };\n    const EVENTS = {\n        showDropdown: 'showDropdown',\n        hideDropdown: 'hideDropdown',\n        change: 'change',\n        choice: 'choice',\n        search: 'search',\n        addItem: 'addItem',\n        removeItem: 'removeItem',\n        highlightItem: 'highlightItem',\n        highlightChoice: 'highlightChoice'\n    };\n    const ACTION_TYPES = {\n        ADD_CHOICE: 'ADD_CHOICE',\n        FILTER_CHOICES: 'FILTER_CHOICES',\n        ACTIVATE_CHOICES: 'ACTIVATE_CHOICES',\n        CLEAR_CHOICES: 'CLEAR_CHOICES',\n        ADD_GROUP: 'ADD_GROUP',\n        ADD_ITEM: 'ADD_ITEM',\n        REMOVE_ITEM: 'REMOVE_ITEM',\n        HIGHLIGHT_ITEM: 'HIGHLIGHT_ITEM',\n        CLEAR_ALL: 'CLEAR_ALL'\n    };\n    const KEY_CODES = {\n        BACK_KEY: 46,\n        DELETE_KEY: 8,\n        ENTER_KEY: 13,\n        A_KEY: 65,\n        ESC_KEY: 27,\n        UP_KEY: 38,\n        DOWN_KEY: 40,\n        PAGE_UP_KEY: 33,\n        PAGE_DOWN_KEY: 34\n    };\n    const TEXT_TYPE = 'text';\n    const SELECT_ONE_TYPE = 'select-one';\n    const SELECT_MULTIPLE_TYPE = 'select-multiple';\n    const SCROLLING_SPEED = 4;\n    return {\n        DEFAULT_CLASSNAMES: DEFAULT_CLASSNAMES,\n        DEFAULT_CONFIG: DEFAULT_CONFIG,\n        EVENTS: EVENTS,\n        ACTION_TYPES: ACTION_TYPES,\n        KEY_CODES: KEY_CODES,\n        TEXT_TYPE: TEXT_TYPE,\n        SELECT_ONE_TYPE: SELECT_ONE_TYPE,\n        SELECT_MULTIPLE_TYPE: SELECT_MULTIPLE_TYPE,\n        SCROLLING_SPEED: SCROLLING_SPEED\n    };\n});\ndefine('skylark-choices/components/container',[\n    '../lib/utils',\n    '../constants'\n], function (utils, constants) {\n    'use strict';\n    return class Container {\n        constructor({element, type, classNames, position}) {\n            this.element = element;\n            this.classNames = classNames;\n            this.type = type;\n            this.position = position;\n            this.isOpen = false;\n            this.isFlipped = false;\n            this.isFocussed = false;\n            this.isDisabled = false;\n            this.isLoading = false;\n            this._onFocus = this._onFocus.bind(this);\n            this._onBlur = this._onBlur.bind(this);\n        }\n        addEventListeners() {\n            this.element.addEventListener('focus', this._onFocus);\n            this.element.addEventListener('blur', this._onBlur);\n        }\n        removeEventListeners() {\n            this.element.removeEventListener('focus', this._onFocus);\n            this.element.removeEventListener('blur', this._onBlur);\n        }\n        shouldFlip(dropdownPos) {\n            if (typeof dropdownPos !== 'number') {\n                return false;\n            }\n            let shouldFlip = false;\n            if (this.position === 'auto') {\n                shouldFlip = !window.matchMedia(`(min-height: ${ dropdownPos + 1 }px)`).matches;\n            } else if (this.position === 'top') {\n                shouldFlip = true;\n            }\n            return shouldFlip;\n        }\n        setActiveDescendant(activeDescendantID) {\n            this.element.setAttribute('aria-activedescendant', activeDescendantID);\n        }\n        removeActiveDescendant() {\n            this.element.removeAttribute('aria-activedescendant');\n        }\n        open(dropdownPos) {\n            this.element.classList.add(this.classNames.openState);\n            this.element.setAttribute('aria-expanded', 'true');\n            this.isOpen = true;\n            if (this.shouldFlip(dropdownPos)) {\n                this.element.classList.add(this.classNames.flippedState);\n                this.isFlipped = true;\n            }\n        }\n        close() {\n            this.element.classList.remove(this.classNames.openState);\n            this.element.setAttribute('aria-expanded', 'false');\n            this.removeActiveDescendant();\n            this.isOpen = false;\n            if (this.isFlipped) {\n                this.element.classList.remove(this.classNames.flippedState);\n                this.isFlipped = false;\n            }\n        }\n        focus() {\n            if (!this.isFocussed) {\n                this.element.focus();\n            }\n        }\n        addFocusState() {\n            this.element.classList.add(this.classNames.focusState);\n        }\n        removeFocusState() {\n            this.element.classList.remove(this.classNames.focusState);\n        }\n        enable() {\n            this.element.classList.remove(this.classNames.disabledState);\n            this.element.removeAttribute('aria-disabled');\n            if (this.type === constants.SELECT_ONE_TYPE) {\n                this.element.setAttribute('tabindex', '0');\n            }\n            this.isDisabled = false;\n        }\n        disable() {\n            this.element.classList.add(this.classNames.disabledState);\n            this.element.setAttribute('aria-disabled', 'true');\n            if (this.type === constants.SELECT_ONE_TYPE) {\n                this.element.setAttribute('tabindex', '-1');\n            }\n            this.isDisabled = true;\n        }\n        wrap(element) {\n            utils.wrap(element, this.element);\n        }\n        unwrap(element) {\n            this.element.parentNode.insertBefore(element, this.element);\n            this.element.parentNode.removeChild(this.element);\n        }\n        addLoadingState() {\n            this.element.classList.add(this.classNames.loadingState);\n            this.element.setAttribute('aria-busy', 'true');\n            this.isLoading = true;\n        }\n        removeLoadingState() {\n            this.element.classList.remove(this.classNames.loadingState);\n            this.element.removeAttribute('aria-busy');\n            this.isLoading = false;\n        }\n        _onFocus() {\n            this.isFocussed = true;\n        }\n        _onBlur() {\n            this.isFocussed = false;\n        }\n    };\n});\ndefine('skylark-choices/components/input',[\n    '../lib/utils',\n    '../constants'\n], function (utils, constants) {\n    'use strict';\n    return class Input {\n        constructor({element, type, classNames, preventPaste}) {\n            this.element = element;\n            this.type = type;\n            this.classNames = classNames;\n            this.preventPaste = preventPaste;\n            this.isFocussed = this.element === document.activeElement;\n            this.isDisabled = element.disabled;\n            this._onPaste = this._onPaste.bind(this);\n            this._onInput = this._onInput.bind(this);\n            this._onFocus = this._onFocus.bind(this);\n            this._onBlur = this._onBlur.bind(this);\n        }\n        set placeholder(placeholder) {\n            this.element.placeholder = placeholder;\n        }\n        get value() {\n            return utils.sanitise(this.element.value);\n        }\n        set value(value) {\n            this.element.value = value;\n        }\n        addEventListeners() {\n            this.element.addEventListener('paste', this._onPaste);\n            this.element.addEventListener('input', this._onInput, { passive: true });\n            this.element.addEventListener('focus', this._onFocus, { passive: true });\n            this.element.addEventListener('blur', this._onBlur, { passive: true });\n        }\n        removeEventListeners() {\n            this.element.removeEventListener('input', this._onInput, { passive: true });\n            this.element.removeEventListener('paste', this._onPaste);\n            this.element.removeEventListener('focus', this._onFocus, { passive: true });\n            this.element.removeEventListener('blur', this._onBlur, { passive: true });\n        }\n        enable() {\n            this.element.removeAttribute('disabled');\n            this.isDisabled = false;\n        }\n        disable() {\n            this.element.setAttribute('disabled', '');\n            this.isDisabled = true;\n        }\n        focus() {\n            if (!this.isFocussed) {\n                this.element.focus();\n            }\n        }\n        blur() {\n            if (this.isFocussed) {\n                this.element.blur();\n            }\n        }\n        clear(setWidth = true) {\n            if (this.element.value) {\n                this.element.value = '';\n            }\n            if (setWidth) {\n                this.setWidth();\n            }\n            return this;\n        }\n        setWidth() {\n            const {style, value, placeholder} = this.element;\n            style.minWidth = `${ placeholder.length + 1 }ch`;\n            style.width = `${ value.length + 1 }ch`;\n        }\n        setActiveDescendant(activeDescendantID) {\n            this.element.setAttribute('aria-activedescendant', activeDescendantID);\n        }\n        removeActiveDescendant() {\n            this.element.removeAttribute('aria-activedescendant');\n        }\n        _onInput() {\n            if (this.type !== constants.SELECT_ONE_TYPE) {\n                this.setWidth();\n            }\n        }\n        _onPaste(event) {\n            if (this.preventPaste) {\n                event.preventDefault();\n            }\n        }\n        _onFocus() {\n            this.isFocussed = true;\n        }\n        _onBlur() {\n            this.isFocussed = false;\n        }\n    };\n});\ndefine('skylark-choices/components/list',[\n    '../constants'\n], function (constants) {\n    'use strict';\n    return class List {\n        constructor({element}) {\n            this.element = element;\n            this.scrollPos = this.element.scrollTop;\n            this.height = this.element.offsetHeight;\n        }\n        clear() {\n            this.element.innerHTML = '';\n        }\n        append(node) {\n            this.element.appendChild(node);\n        }\n        getChild(selector) {\n            return this.element.querySelector(selector);\n        }\n        hasChildren() {\n            return this.element.hasChildNodes();\n        }\n        scrollToTop() {\n            this.element.scrollTop = 0;\n        }\n        scrollToChildElement(element, direction) {\n            if (!element) {\n                return;\n            }\n            const listHeight = this.element.offsetHeight;\n            const listScrollPosition = this.element.scrollTop + listHeight;\n            const elementHeight = element.offsetHeight;\n            const elementPos = element.offsetTop + elementHeight;\n            const destination = direction > 0 ? this.element.scrollTop + elementPos - listScrollPosition : element.offsetTop;\n            requestAnimationFrame(() => {\n                this._animateScroll(destination, direction);\n            });\n        }\n        _scrollDown(scrollPos, strength, destination) {\n            const easing = (destination - scrollPos) / strength;\n            const distance = easing > 1 ? easing : 1;\n            this.element.scrollTop = scrollPos + distance;\n        }\n        _scrollUp(scrollPos, strength, destination) {\n            const easing = (scrollPos - destination) / strength;\n            const distance = easing > 1 ? easing : 1;\n            this.element.scrollTop = scrollPos - distance;\n        }\n        _animateScroll(destination, direction) {\n            const strength = constants.SCROLLING_SPEED;\n            const choiceListScrollTop = this.element.scrollTop;\n            let continueAnimation = false;\n            if (direction > 0) {\n                this._scrollDown(choiceListScrollTop, strength, destination);\n                if (choiceListScrollTop < destination) {\n                    continueAnimation = true;\n                }\n            } else {\n                this._scrollUp(choiceListScrollTop, strength, destination);\n                if (choiceListScrollTop > destination) {\n                    continueAnimation = true;\n                }\n            }\n            if (continueAnimation) {\n                requestAnimationFrame(() => {\n                    this._animateScroll(destination, direction);\n                });\n            }\n        }\n    };\n});\ndefine('skylark-choices/components/wrapped-element',[\n    '../lib/utils'\n], function (utils) {\n    'use strict';\n    return class WrappedElement {\n        constructor({element, classNames}) {\n            this.element = element;\n            this.classNames = classNames;\n            if (!(element instanceof HTMLInputElement) && !(element instanceof HTMLSelectElement)) {\n                throw new TypeError('Invalid element passed');\n            }\n            this.isDisabled = false;\n        }\n        get isActive() {\n            return this.element.dataset.choice === 'active';\n        }\n        get dir() {\n            return this.element.dir;\n        }\n        get value() {\n            return this.element.value;\n        }\n        set value(value) {\n            this.element.value = value;\n        }\n        conceal() {\n            this.element.classList.add(this.classNames.input);\n            this.element.hidden = true;\n            this.element.tabIndex = -1;\n            const origStyle = this.element.getAttribute('style');\n            if (origStyle) {\n                this.element.setAttribute('data-choice-orig-style', origStyle);\n            }\n            this.element.setAttribute('data-choice', 'active');\n        }\n        reveal() {\n            this.element.classList.remove(this.classNames.input);\n            this.element.hidden = false;\n            this.element.removeAttribute('tabindex');\n            const origStyle = this.element.getAttribute('data-choice-orig-style');\n            if (origStyle) {\n                this.element.removeAttribute('data-choice-orig-style');\n                this.element.setAttribute('style', origStyle);\n            } else {\n                this.element.removeAttribute('style');\n            }\n            this.element.removeAttribute('data-choice');\n            this.element.value = this.element.value;\n        }\n        enable() {\n            this.element.removeAttribute('disabled');\n            this.element.disabled = false;\n            this.isDisabled = false;\n        }\n        disable() {\n            this.element.setAttribute('disabled', '');\n            this.element.disabled = true;\n            this.isDisabled = true;\n        }\n        triggerEvent(eventType, data) {\n            utils.dispatchEvent(this.element, eventType, data);\n        }\n    };\n});\ndefine('skylark-choices/components/wrapped-input',[\n    './wrapped-element'\n], function (WrappedElement) {\n    'use strict';\n    return class WrappedInput extends WrappedElement {\n        constructor({element, classNames, delimiter}) {\n            super({\n                element,\n                classNames\n            });\n            this.delimiter = delimiter;\n        }\n        get value() {\n            return this.element.value;\n        }\n        set value(items) {\n            const itemValues = items.map(({value}) => value);\n            const joinedValues = itemValues.join(this.delimiter);\n            this.element.setAttribute('value', joinedValues);\n            this.element.value = joinedValues;\n        }\n    };\n});\ndefine('skylark-choices/components/wrapped-select',[\n    './wrapped-element'\n], function (WrappedElement) {\n    'use strict';\n    return class WrappedSelect extends WrappedElement {\n        constructor({element, classNames, template}) {\n            super({\n                element,\n                classNames\n            });\n            this.template = template;\n        }\n        get placeholderOption() {\n            return this.element.querySelector('option[value=\"\"]') || this.element.querySelector('option[placeholder]');\n        }\n        get optionGroups() {\n            return Array.from(this.element.getElementsByTagName('OPTGROUP'));\n        }\n        get options() {\n            return Array.from(this.element.options);\n        }\n        set options(options) {\n            const fragment = document.createDocumentFragment();\n            const addOptionToFragment = data => {\n                const option = this.template(data);\n                fragment.appendChild(option);\n            };\n            options.forEach(optionData => addOptionToFragment(optionData));\n            this.appendDocFragment(fragment);\n        }\n        appendDocFragment(fragment) {\n            this.element.innerHTML = '';\n            this.element.appendChild(fragment);\n        }\n    };\n});\ndefine('skylark-choices/components/index',[\n    './dropdown',\n    './container',\n    './input',\n    './list',\n    './wrapped-input',\n    './wrapped-select'\n], function (Dropdown, Container, Input, List, WrappedInput, WrappedSelect) {\n    'use strict';\n    return {\n        Dropdown,\n        Container,\n        Input,\n        List,\n        WrappedInput,\n        WrappedSelect\n    };\n});\ndefine('skylark-choices/templates',[],function () {\n    'use strict';\n    const TEMPLATES = {\n        containerOuter({containerOuter}, dir, isSelectElement, isSelectOneElement, searchEnabled, passedElementType) {\n            const div = Object.assign(document.createElement('div'), { className: containerOuter });\n            div.dataset.type = passedElementType;\n            if (dir) {\n                div.dir = dir;\n            }\n            if (isSelectOneElement) {\n                div.tabIndex = 0;\n            }\n            if (isSelectElement) {\n                div.setAttribute('role', searchEnabled ? 'combobox' : 'listbox');\n                if (searchEnabled) {\n                    div.setAttribute('aria-autocomplete', 'list');\n                }\n            }\n            div.setAttribute('aria-haspopup', 'true');\n            div.setAttribute('aria-expanded', 'false');\n            return div;\n        },\n        containerInner({containerInner}) {\n            return Object.assign(document.createElement('div'), { className: containerInner });\n        },\n        itemList({list, listSingle, listItems}, isSelectOneElement) {\n            return Object.assign(document.createElement('div'), { className: `${ list } ${ isSelectOneElement ? listSingle : listItems }` });\n        },\n        placeholder({placeholder}, value) {\n            return Object.assign(document.createElement('div'), {\n                className: placeholder,\n                innerHTML: value\n            });\n        },\n        item({item, button, highlightedState, itemSelectable, placeholder}, {\n            id,\n            value,\n            label,\n            customProperties,\n            active,\n            disabled,\n            highlighted,\n            placeholder: isPlaceholder\n        }, removeItemButton) {\n            const div = Object.assign(document.createElement('div'), {\n                className: item,\n                innerHTML: label\n            });\n            Object.assign(div.dataset, {\n                item: '',\n                id,\n                value,\n                customProperties\n            });\n            if (active) {\n                div.setAttribute('aria-selected', 'true');\n            }\n            if (disabled) {\n                div.setAttribute('aria-disabled', 'true');\n            }\n            if (isPlaceholder) {\n                div.classList.add(placeholder);\n            }\n            div.classList.add(highlighted ? highlightedState : itemSelectable);\n            if (removeItemButton) {\n                if (disabled) {\n                    div.classList.remove(itemSelectable);\n                }\n                div.dataset.deletable = '';\n                const REMOVE_ITEM_TEXT = 'Remove item';\n                const removeButton = Object.assign(document.createElement('button'), {\n                    type: 'button',\n                    className: button,\n                    innerHTML: REMOVE_ITEM_TEXT\n                });\n                removeButton.setAttribute('aria-label', `${ REMOVE_ITEM_TEXT }: '${ value }'`);\n                removeButton.dataset.button = '';\n                div.appendChild(removeButton);\n            }\n            return div;\n        },\n        choiceList({list}, isSelectOneElement) {\n            const div = Object.assign(document.createElement('div'), { className: list });\n            if (!isSelectOneElement) {\n                div.setAttribute('aria-multiselectable', 'true');\n            }\n            div.setAttribute('role', 'listbox');\n            return div;\n        },\n        choiceGroup({group, groupHeading, itemDisabled}, {id, value, disabled}) {\n            const div = Object.assign(document.createElement('div'), { className: `${ group } ${ disabled ? itemDisabled : '' }` });\n            div.setAttribute('role', 'group');\n            Object.assign(div.dataset, {\n                group: '',\n                id,\n                value\n            });\n            if (disabled) {\n                div.setAttribute('aria-disabled', 'true');\n            }\n            div.appendChild(Object.assign(document.createElement('div'), {\n                className: groupHeading,\n                innerHTML: value\n            }));\n            return div;\n        },\n        choice({item, itemChoice, itemSelectable, selectedState, itemDisabled, placeholder}, {\n            id,\n            value,\n            label,\n            groupId,\n            elementId,\n            disabled: isDisabled,\n            selected: isSelected,\n            placeholder: isPlaceholder\n        }, selectText) {\n            const div = Object.assign(document.createElement('div'), {\n                id: elementId,\n                innerHTML: label,\n                className: `${ item } ${ itemChoice }`\n            });\n            if (isSelected) {\n                div.classList.add(selectedState);\n            }\n            if (isPlaceholder) {\n                div.classList.add(placeholder);\n            }\n            div.setAttribute('role', groupId > 0 ? 'treeitem' : 'option');\n            Object.assign(div.dataset, {\n                choice: '',\n                id,\n                value,\n                selectText\n            });\n            if (isDisabled) {\n                div.classList.add(itemDisabled);\n                div.dataset.choiceDisabled = '';\n                div.setAttribute('aria-disabled', 'true');\n            } else {\n                div.classList.add(itemSelectable);\n                div.dataset.choiceSelectable = '';\n            }\n            return div;\n        },\n        input({input, inputCloned}, placeholderValue) {\n            const inp = Object.assign(document.createElement('input'), {\n                type: 'text',\n                className: `${ input } ${ inputCloned }`,\n                autocomplete: 'off',\n                autocapitalize: 'off',\n                spellcheck: false\n            });\n            inp.setAttribute('role', 'textbox');\n            inp.setAttribute('aria-autocomplete', 'list');\n            inp.setAttribute('aria-label', placeholderValue);\n            return inp;\n        },\n        dropdown({list, listDropdown}) {\n            const div = document.createElement('div');\n            div.classList.add(list, listDropdown);\n            div.setAttribute('aria-expanded', 'false');\n            return div;\n        },\n        notice({item, itemChoice, noResults, noChoices}, innerHTML, type = '') {\n            const classes = [\n                item,\n                itemChoice\n            ];\n            if (type === 'no-choices') {\n                classes.push(noChoices);\n            } else if (type === 'no-results') {\n                classes.push(noResults);\n            }\n            return Object.assign(document.createElement('div'), {\n                innerHTML,\n                className: classes.join(' ')\n            });\n        },\n        option({label, value, customProperties, active, disabled}) {\n            const opt = new Option(label, value, false, active);\n            if (customProperties) {\n                opt.dataset.customProperties = customProperties;\n            }\n            opt.disabled = disabled;\n            return opt;\n        }\n    };\n    return TEMPLATES;\n});\ndefine('skylark-choices/actions/choices',[\n    '../constants'\n], function (constants) {\n    'use strict';\n    const addChoice = ({\n        value, \n        label, \n        id, \n        groupId, \n        disabled, \n        elementId, \n        customProperties, \n        placeholder, \n        keyCode\n    }) => ({\n        type: constants.ACTION_TYPES.ADD_CHOICE,\n        value,\n        label,\n        id,\n        groupId,\n        disabled,\n        elementId,\n        customProperties,\n        placeholder,\n        keyCode\n    });\n    const filterChoices = results => ({\n        type: constants.ACTION_TYPES.FILTER_CHOICES,\n        results\n    });\n    const activateChoices = (active = true) => ({\n        type: constants.ACTION_TYPES.ACTIVATE_CHOICES,\n        active\n    });\n    const clearChoices = () => ({ type: constants.ACTION_TYPES.CLEAR_CHOICES });\n    return {\n        addChoice: addChoice,\n        filterChoices: filterChoices,\n        activateChoices: activateChoices,\n        clearChoices: clearChoices\n    };\n});\ndefine('skylark-choices/actions/items',[\n    '../constants'\n], function (constants) {\n    'use strict';\n    const addItem = ({value, label, id, choiceId, groupId, customProperties, placeholder, keyCode}) => ({\n        type: constants.ACTION_TYPES.ADD_ITEM,\n        value,\n        label,\n        id,\n        choiceId,\n        groupId,\n        customProperties,\n        placeholder,\n        keyCode\n    });\n    const removeItem = (id, choiceId) => ({\n        type: constants.ACTION_TYPES.REMOVE_ITEM,\n        id,\n        choiceId\n    });\n    const highlightItem = (id, highlighted) => ({\n        type: constants.ACTION_TYPES.HIGHLIGHT_ITEM,\n        id,\n        highlighted\n    });\n    return {\n        addItem: addItem,\n        removeItem: removeItem,\n        highlightItem: highlightItem\n    };\n});\ndefine('skylark-choices/actions/groups',['../constants'], function (constants) {\n    'use strict';\n    const addGroup = ({value, id, active, disabled}) => ({\n        type: constants.ACTION_TYPES.ADD_GROUP,\n        value,\n        id,\n        active,\n        disabled\n    });\n    return { addGroup: addGroup };\n});\ndefine('skylark-choices/actions/misc',[],function () {\n    'use strict';\n    const clearAll = () => ({ type: 'CLEAR_ALL' });\n    const resetTo = state => ({\n        type: 'RESET_TO',\n        state\n    });\n    const setIsLoading = isLoading => ({\n        type: 'SET_IS_LOADING',\n        isLoading\n    });\n    return {\n        clearAll: clearAll,\n        resetTo: resetTo,\n        setIsLoading: setIsLoading\n    };\n});\ndefine('skylark-choices/choices',[\n    './vendors/fuse',\n    './vendors/deepmerge',\n    './store/store',\n    './components/index',\n    './constants',\n    './templates',\n    './actions/choices',\n    './actions/items',\n    './actions/groups',\n    './actions/misc',\n    './lib/utils'\n], function (Fuse, merge, Store, components, constants, TEMPLATES, actionsChoices, items, groups, misc, h) {\n    'use strict';\n    const IS_IE11 = '-ms-scroll-limit' in document.documentElement.style && '-ms-ime-align' in document.documentElement.style;\n    const USER_DEFAULTS = {};\n    class Choices {\n        static get defaults() {\n            return Object.preventExtensions({\n                get options() {\n                    return USER_DEFAULTS;\n                },\n                get templates() {\n                    return TEMPLATES;\n                }\n            });\n        }\n        constructor(element = '[data-choice]', userConfig = {}) {\n            this.config = merge.all([\n                constants.DEFAULT_CONFIG,\n                Choices.defaults.options,\n                userConfig\n            ], { arrayMerge: (_, sourceArray) => [...sourceArray] });\n            const invalidConfigOptions = h.diff(this.config, constants.DEFAULT_CONFIG);\n            if (invalidConfigOptions.length) {\n                console.warn('Unknown config option(s) passed', invalidConfigOptions.join(', '));\n            }\n            const passedElement = typeof element === 'string' ? document.querySelector(element) : element;\n            if (!(passedElement instanceof HTMLInputElement || passedElement instanceof HTMLSelectElement)) {\n                throw TypeError('Expected one of the following types text|select-one|select-multiple');\n            }\n            this._isTextElement = passedElement.type === constants.TEXT_TYPE;\n            this._isSelectOneElement = passedElement.type === constants.SELECT_ONE_TYPE;\n            this._isSelectMultipleElement = passedElement.type === constants.SELECT_MULTIPLE_TYPE;\n            this._isSelectElement = this._isSelectOneElement || this._isSelectMultipleElement;\n            this.config.searchEnabled = this._isSelectMultipleElement || this.config.searchEnabled;\n            if (![\n                    'auto',\n                    'always'\n                ].includes(this.config.renderSelectedChoices)) {\n                this.config.renderSelectedChoices = 'auto';\n            }\n            if (userConfig.addItemFilter && typeof userConfig.addItemFilter !== 'function') {\n                const re = userConfig.addItemFilter instanceof RegExp ? userConfig.addItemFilter : new RegExp(userConfig.addItemFilter);\n                this.config.addItemFilter = re.test.bind(re);\n            }\n            if (this._isTextElement) {\n                this.passedElement = new components.WrappedInput({\n                    element: passedElement,\n                    classNames: this.config.classNames,\n                    delimiter: this.config.delimiter\n                });\n            } else {\n                this.passedElement = new components.WrappedSelect({\n                    element: passedElement,\n                    classNames: this.config.classNames,\n                    template: data => this._templates.option(data)\n                });\n            }\n            this.initialised = false;\n            this._store = new Store();\n            this._initialState = {};\n            this._currentState = {};\n            this._prevState = {};\n            this._currentValue = '';\n            this._canSearch = this.config.searchEnabled;\n            this._isScrollingOnIe = false;\n            this._highlightPosition = 0;\n            this._wasTap = true;\n            this._placeholderValue = this._generatePlaceholderValue();\n            this._baseId = h.generateId(this.passedElement.element, 'choices-');\n            this._direction = this.passedElement.dir;\n            if (!this._direction) {\n                const {direction: elementDirection} = window.getComputedStyle(this.passedElement.element);\n                const {direction: documentDirection} = window.getComputedStyle(document.documentElement);\n                if (elementDirection !== documentDirection) {\n                    this._direction = elementDirection;\n                }\n            }\n            this._idNames = { itemChoice: 'item-choice' };\n            this._presetGroups = this.passedElement.optionGroups;\n            this._presetOptions = this.passedElement.options;\n            this._presetChoices = this.config.choices;\n            this._presetItems = this.config.items;\n            if (this.passedElement.value) {\n                this._presetItems = this._presetItems.concat(this.passedElement.value.split(this.config.delimiter));\n            }\n            if (this.passedElement.options) {\n                this.passedElement.options.forEach(o => {\n                    this._presetChoices.push({\n                        value: o.value,\n                        label: o.innerHTML,\n                        selected: o.selected,\n                        disabled: o.disabled || o.parentNode.disabled,\n                        placeholder: o.value === '' || o.hasAttribute('placeholder'),\n                        customProperties: o.getAttribute('data-custom-properties')\n                    });\n                });\n            }\n            this._render = this._render.bind(this);\n            this._onFocus = this._onFocus.bind(this);\n            this._onBlur = this._onBlur.bind(this);\n            this._onKeyUp = this._onKeyUp.bind(this);\n            this._onKeyDown = this._onKeyDown.bind(this);\n            this._onClick = this._onClick.bind(this);\n            this._onTouchMove = this._onTouchMove.bind(this);\n            this._onTouchEnd = this._onTouchEnd.bind(this);\n            this._onMouseDown = this._onMouseDown.bind(this);\n            this._onMouseOver = this._onMouseOver.bind(this);\n            this._onFormReset = this._onFormReset.bind(this);\n            this._onAKey = this._onAKey.bind(this);\n            this._onEnterKey = this._onEnterKey.bind(this);\n            this._onEscapeKey = this._onEscapeKey.bind(this);\n            this._onDirectionKey = this._onDirectionKey.bind(this);\n            this._onDeleteKey = this._onDeleteKey.bind(this);\n            if (this.passedElement.isActive) {\n                if (!this.config.silent) {\n                    console.warn('Trying to initialise Choices on element already initialised');\n                }\n                this.initialised = true;\n                return;\n            }\n            this.init();\n        }\n        init() {\n            if (this.initialised) {\n                return;\n            }\n            this._createTemplates();\n            this._createElements();\n            this._createStructure();\n            this._initialState = h.cloneObject(this._store.state);\n            this._store.subscribe(this._render);\n            this._render();\n            this._addEventListeners();\n            const shouldDisable = !this.config.addItems || this.passedElement.element.hasAttribute('disabled');\n            if (shouldDisable) {\n                this.disable();\n            }\n            this.initialised = true;\n            const {callbackOnInit} = this.config;\n            if (callbackOnInit && typeof callbackOnInit === 'function') {\n                callbackOnInit.call(this);\n            }\n        }\n        destroy() {\n            if (!this.initialised) {\n                return;\n            }\n            this._removeEventListeners();\n            this.passedElement.reveal();\n            this.containerOuter.unwrap(this.passedElement.element);\n            this.clearStore();\n            if (this._isSelectElement) {\n                this.passedElement.options = this._presetOptions;\n            }\n            this._templates = null;\n            this.initialised = false;\n        }\n        enable() {\n            if (this.passedElement.isDisabled) {\n                this.passedElement.enable();\n            }\n            if (this.containerOuter.isDisabled) {\n                this._addEventListeners();\n                this.input.enable();\n                this.containerOuter.enable();\n            }\n            return this;\n        }\n        disable() {\n            if (!this.passedElement.isDisabled) {\n                this.passedElement.disable();\n            }\n            if (!this.containerOuter.isDisabled) {\n                this._removeEventListeners();\n                this.input.disable();\n                this.containerOuter.disable();\n            }\n            return this;\n        }\n        highlightItem(item, runEvent = true) {\n            if (!item) {\n                return this;\n            }\n            const {id, groupId = -1, value = '', label = ''} = item;\n            const group = groupId >= 0 ? this._store.getGroupById(groupId) : null;\n            this._store.dispatch(items.highlightItem(id, true));\n            if (runEvent) {\n                this.passedElement.triggerEvent(constants.EVENTS.undefined, {\n                    id,\n                    value,\n                    label,\n                    groupValue: group && group.value ? group.value : null\n                });\n            }\n            return this;\n        }\n        unhighlightItem(item) {\n            if (!item) {\n                return this;\n            }\n            const {id, groupId = -1, value = '', label = ''} = item;\n            const group = groupId >= 0 ? this._store.getGroupById(groupId) : null;\n            this._store.dispatch(items.highlightItem(id, false));\n            this.passedElement.triggerEvent(constants.EVENTS.undefined, {\n                id,\n                value,\n                label,\n                groupValue: group && group.value ? group.value : null\n            });\n            return this;\n        }\n        highlightAll() {\n            this._store.items.forEach(item => this.undefined(item));\n            return this;\n        }\n        unhighlightAll() {\n            this._store.items.forEach(item => this.unhighlightItem(item));\n            return this;\n        }\n        removeActiveItemsByValue(value) {\n            this._store.activeItems.filter(item => item.value === value).forEach(item => this._removeItem(item));\n            return this;\n        }\n        removeActiveItems(excludedId) {\n            this._store.activeItems.filter(({id}) => id !== excludedId).forEach(item => this._removeItem(item));\n            return this;\n        }\n        removeHighlightedItems(runEvent = false) {\n            this._store.highlightedActiveItems.forEach(item => {\n                this._removeItem(item);\n                if (runEvent) {\n                    this._triggerChange(item.value);\n                }\n            });\n            return this;\n        }\n        showDropdown(preventInputFocus) {\n            if (this.dropdown.isActive) {\n                return this;\n            }\n            requestAnimationFrame(() => {\n                this.dropdown.show();\n                this.containerOuter.open(this.dropdown.distanceFromTopWindow);\n                if (!preventInputFocus && this._canSearch) {\n                    this.input.focus();\n                }\n                this.passedElement.triggerEvent(constants.EVENTS.showDropdown, {});\n            });\n            return this;\n        }\n        hideDropdown(preventInputBlur) {\n            if (!this.dropdown.isActive) {\n                return this;\n            }\n            requestAnimationFrame(() => {\n                this.dropdown.hide();\n                this.containerOuter.close();\n                if (!preventInputBlur && this._canSearch) {\n                    this.input.removeActiveDescendant();\n                    this.input.blur();\n                }\n                this.passedElement.triggerEvent(constants.EVENTS.hideDropdown, {});\n            });\n            return this;\n        }\n        getValue(valueOnly = false) {\n            const values = this._store.activeItems.reduce((selectedItems, item) => {\n                const itemValue = valueOnly ? item.value : item;\n                selectedItems.push(itemValue);\n                return selectedItems;\n            }, []);\n            return this._isSelectOneElement ? values[0] : values;\n        }\n        setValue(items) {\n            if (!this.initialised) {\n                return this;\n            }\n            items.forEach(value => this._setChoiceOrItem(value));\n            return this;\n        }\n        setChoiceByValue(value) {\n            if (!this.initialised || this._isTextElement) {\n                return this;\n            }\n            const choiceValue = Array.isArray(value) ? value : [value];\n            choiceValue.forEach(val => this._findAndSelectChoiceByValue(val));\n            return this;\n        }\n        setChoices(choicesArrayOrFetcher = [], value = 'value', label = 'label', replaceChoices = false) {\n            if (!this.initialised) {\n                throw new ReferenceError(`setChoices was called on a non-initialized instance of Choices`);\n            }\n            if (!this._isSelectElement) {\n                throw new TypeError(`setChoices can't be used with INPUT based Choices`);\n            }\n            if (typeof value !== 'string' || !value) {\n                throw new TypeError(`value parameter must be a name of 'value' field in passed objects`);\n            }\n            if (replaceChoices) {\n                this.undefined();\n            }\n            if (typeof choicesArrayOrFetcher === 'function') {\n                const fetcher = choicesArrayOrFetcher(this);\n                if (typeof Promise === 'function' && fetcher instanceof Promise) {\n                    return new Promise(resolve => requestAnimationFrame(resolve)).then(() => this._handleLoadingState(true)).then(() => fetcher).then(data => this.setChoices(data, value, label, replaceChoices)).catch(err => {\n                        if (!this.config.silent) {\n                            console.error(err);\n                        }\n                    }).then(() => this._handleLoadingState(false)).then(() => this);\n                }\n                if (!Array.isArray(fetcher)) {\n                    throw new TypeError(`.setChoices first argument function must return either array of choices or Promise, got: ${ typeof fetcher }`);\n                }\n                return this.setChoices(fetcher, value, label, false);\n            }\n            if (!Array.isArray(choicesArrayOrFetcher)) {\n                throw new TypeError(`.setChoices must be called either with array of choices with a function resulting into Promise of array of choices`);\n            }\n            this.containerOuter.removeLoadingState();\n            this._startLoading();\n            choicesArrayOrFetcher.forEach(groupOrChoice => {\n                if (groupOrChoice.choices) {\n                    this._addGroup({\n                        id: parseInt(groupOrChoice.id, 10) || null,\n                        group: groupOrChoice,\n                        valueKey: value,\n                        labelKey: label\n                    });\n                } else {\n                    this._addChoice({\n                        value: groupOrChoice[value],\n                        label: groupOrChoice[label],\n                        isSelected: groupOrChoice.selected,\n                        isDisabled: groupOrChoice.disabled,\n                        customProperties: groupOrChoice.customProperties,\n                        placeholder: groupOrChoice.placeholder\n                    });\n                }\n            });\n            this._stopLoading();\n            return this;\n        }\n        clearChoices() {\n            this._store.dispatch(actionsChoices.clearChoices());\n            return this;\n        }\n        clearStore() {\n            this._store.dispatch(misc.clearAll());\n            return this;\n        }\n        clearInput() {\n            const shouldSetInputWidth = !this._isSelectOneElement;\n            this.input.clear(shouldSetInputWidth);\n            if (!this._isTextElement && this._canSearch) {\n                this._isSearching = false;\n                this._store.dispatch(d.activateChoices(true));\n            }\n            return this;\n        }\n        _render() {\n            if (this._store.isLoading()) {\n                return;\n            }\n            this._currentState = this._store.state;\n            const stateChanged = this._currentState.choices !== this._prevState.choices || this._currentState.groups !== this._prevState.groups || this._currentState.items !== this._prevState.items;\n            const shouldRenderChoices = this._isSelectElement;\n            const shouldRenderItems = this._currentState.items !== this._prevState.items;\n            if (!stateChanged) {\n                return;\n            }\n            if (shouldRenderChoices) {\n                this._renderChoices();\n            }\n            if (shouldRenderItems) {\n                this._renderItems();\n            }\n            this._prevState = this._currentState;\n        }\n        _renderChoices() {\n            const {activeGroups, activeChoices} = this._store;\n            let choiceListFragment = document.createDocumentFragment();\n            this.choiceList.clear();\n            if (this.config.resetScrollPosition) {\n                requestAnimationFrame(() => this.choiceList.scrollToTop());\n            }\n            if (activeGroups.length >= 1 && !this._isSearching) {\n                const activePlaceholders = activeChoices.filter(activeChoice => activeChoice.placeholder === true && activeChoice.groupId === -1);\n                if (activePlaceholders.length >= 1) {\n                    choiceListFragment = this._createChoicesFragment(activePlaceholders, choiceListFragment);\n                }\n                choiceListFragment = this._createGroupsFragment(activeGroups, activeChoices, choiceListFragment);\n            } else if (activeChoices.length >= 1) {\n                choiceListFragment = this._createChoicesFragment(activeChoices, choiceListFragment);\n            }\n            if (choiceListFragment.childNodes && choiceListFragment.childNodes.length > 0) {\n                const {activeItems} = this._store;\n                const canAddItem = this._canAddItem(activeItems, this.input.value);\n                if (canAddItem.response) {\n                    this.choiceList.append(choiceListFragment);\n                    this._highlightChoice();\n                } else {\n                    this.choiceList.append(this._getTemplate('notice', canAddItem.notice));\n                }\n            } else {\n                let dropdownItem;\n                let notice;\n                if (this._isSearching) {\n                    notice = typeof this.config.noResultsText === 'function' ? this.config.noResultsText() : this.config.noResultsText;\n                    dropdownItem = this._getTemplate('notice', notice, 'no-results');\n                } else {\n                    notice = typeof this.config.noChoicesText === 'function' ? this.config.noChoicesText() : this.config.noChoicesText;\n                    dropdownItem = this._getTemplate('notice', notice, 'no-choices');\n                }\n                this.choiceList.append(dropdownItem);\n            }\n        }\n        _renderItems() {\n            const activeItems = this._store.activeItems || [];\n            this.itemList.clear();\n            const itemListFragment = this._createItemsFragment(activeItems);\n            if (itemListFragment.childNodes) {\n                this.itemList.append(itemListFragment);\n            }\n        }\n        _createGroupsFragment(groups, choices, fragment = document.createDocumentFragment()) {\n            const getGroupChoices = group => choices.filter(choice => {\n                if (this._isSelectOneElement) {\n                    return choice.groupId === group.id;\n                }\n                return choice.groupId === group.id && (this.config.renderSelectedChoices === 'always' || !choice.selected);\n            });\n            if (this.config.shouldSort) {\n                groups.sort(this.config.sorter);\n            }\n            groups.forEach(group => {\n                const groupChoices = getGroupChoices(group);\n                if (groupChoices.length >= 1) {\n                    const dropdownGroup = this._getTemplate('choiceGroup', group);\n                    fragment.appendChild(dropdownGroup);\n                    this._createChoicesFragment(groupChoices, fragment, true);\n                }\n            });\n            return fragment;\n        }\n        _createChoicesFragment(choices, fragment = document.createDocumentFragment(), withinGroup = false) {\n            const {renderSelectedChoices, searchResultLimit, renderChoiceLimit} = this.config;\n            const filter = this._isSearching ? h.sortByScore : this.config.sorter;\n            const appendChoice = choice => {\n                const shouldRender = renderSelectedChoices === 'auto' ? this._isSelectOneElement || !choice.selected : true;\n                if (shouldRender) {\n                    const dropdownItem = this._getTemplate('choice', choice, this.config.itemSelectText);\n                    fragment.appendChild(dropdownItem);\n                }\n            };\n            let rendererableChoices = choices;\n            if (renderSelectedChoices === 'auto' && !this._isSelectOneElement) {\n                rendererableChoices = choices.filter(choice => !choice.selected);\n            }\n            const {placeholderChoices, normalChoices} = rendererableChoices.reduce((acc, choice) => {\n                if (choice.placeholder) {\n                    acc.placeholderChoices.push(choice);\n                } else {\n                    acc.normalChoices.push(choice);\n                }\n                return acc;\n            }, {\n                placeholderChoices: [],\n                normalChoices: []\n            });\n            if (this.config.shouldSort || this._isSearching) {\n                normalChoices.sort(filter);\n            }\n            let choiceLimit = rendererableChoices.length;\n            const sortedChoices = this._isSelectOneElement ? [\n                ...placeholderChoices,\n                ...normalChoices\n            ] : normalChoices;\n            if (this._isSearching) {\n                choiceLimit = searchResultLimit;\n            } else if (renderChoiceLimit && renderChoiceLimit > 0 && !withinGroup) {\n                choiceLimit = renderChoiceLimit;\n            }\n            for (let i = 0; i < choiceLimit; i += 1) {\n                if (sortedChoices[i]) {\n                    appendChoice(sortedChoices[i]);\n                }\n            }\n            return fragment;\n        }\n        _createItemsFragment(items, fragment = document.createDocumentFragment()) {\n            const {shouldSortItems, sorter, removeItemButton} = this.config;\n            if (shouldSortItems && !this._isSelectOneElement) {\n                items.sort(sorter);\n            }\n            if (this._isTextElement) {\n                this.passedElement.value = items;\n            } else {\n                this.passedElement.options = items;\n            }\n            const addItemToFragment = item => {\n                const listItem = this._getTemplate('item', item, removeItemButton);\n                fragment.appendChild(listItem);\n            };\n            items.forEach(addItemToFragment);\n            return fragment;\n        }\n        _triggerChange(value) {\n            if (value === undefined || value === null) {\n                return;\n            }\n            this.passedElement.triggerEvent(constants.EVENTS.change, { value });\n        }\n        _selectPlaceholderChoice() {\n            const {placeholderChoice} = this._store;\n            if (placeholderChoice) {\n                this._addItem({\n                    value: placeholderChoice.value,\n                    label: placeholderChoice.label,\n                    choiceId: placeholderChoice.id,\n                    groupId: placeholderChoice.groupId,\n                    placeholder: placeholderChoice.placeholder\n                });\n                this._triggerChange(placeholderChoice.value);\n            }\n        }\n        _handleButtonAction(activeItems, element) {\n            if (!activeItems || !element || !this.config.removeItems || !this.config.removeItemButton) {\n                return;\n            }\n            const itemId = element.parentNode.getAttribute('data-id');\n            const itemToRemove = activeItems.find(item => item.id === parseInt(itemId, 10));\n            this._removeItem(itemToRemove);\n            this._triggerChange(itemToRemove.value);\n            if (this._isSelectOneElement) {\n                this._selectPlaceholderChoice();\n            }\n        }\n        _handleItemAction(activeItems, element, hasShiftKey = false) {\n            if (!activeItems || !element || !this.config.removeItems || this._isSelectOneElement) {\n                return;\n            }\n            const passedId = element.getAttribute('data-id');\n            activeItems.forEach(item => {\n                if (item.id === parseInt(passedId, 10) && !item.highlighted) {\n                    this.undefined(item);\n                } else if (!hasShiftKey && item.highlighted) {\n                    this.unhighlightItem(item);\n                }\n            });\n            this.input.focus();\n        }\n        _handleChoiceAction(activeItems, element) {\n            if (!activeItems || !element) {\n                return;\n            }\n            const {id} = element.dataset;\n            const choice = this._store.getChoiceById(id);\n            if (!choice) {\n                return;\n            }\n            const passedKeyCode = activeItems[0] && activeItems[0].keyCode ? activeItems[0].keyCode : null;\n            const hasActiveDropdown = this.dropdown.isActive;\n            choice.keyCode = passedKeyCode;\n            this.passedElement.triggerEvent(constants.EVENTS.choice, { choice });\n            if (!choice.selected && !choice.disabled) {\n                const canAddItem = this._canAddItem(activeItems, choice.value);\n                if (canAddItem.response) {\n                    this._addItem({\n                        value: choice.value,\n                        label: choice.label,\n                        choiceId: choice.id,\n                        groupId: choice.groupId,\n                        customProperties: choice.customProperties,\n                        placeholder: choice.placeholder,\n                        keyCode: choice.keyCode\n                    });\n                    this._triggerChange(choice.value);\n                }\n            }\n            this.clearInput();\n            if (hasActiveDropdown && this._isSelectOneElement) {\n                this.hideDropdown(true);\n                this.containerOuter.focus();\n            }\n        }\n        _handleBackspace(activeItems) {\n            if (!this.config.removeItems || !activeItems) {\n                return;\n            }\n            const lastItem = activeItems[activeItems.length - 1];\n            const hasHighlightedItems = activeItems.some(item => item.highlighted);\n            if (this.config.editItems && !hasHighlightedItems && lastItem) {\n                this.input.value = lastItem.value;\n                this.input.setWidth();\n                this._removeItem(lastItem);\n                this._triggerChange(lastItem.value);\n            } else {\n                if (!hasHighlightedItems) {\n                    this.undefined(lastItem, false);\n                }\n                this.removeHighlightedItems(true);\n            }\n        }\n        _startLoading() {\n            this._store.dispatch(misc.setIsLoading(true));\n        }\n        _stopLoading() {\n            this._store.dispatch(misc.setIsLoading(false));\n        }\n        _handleLoadingState(setLoading = true) {\n            let placeholderItem = this.itemList.getChild(`.${ this.config.classNames.placeholder }`);\n            if (setLoading) {\n                this.disable();\n                this.containerOuter.addLoadingState();\n                if (this._isSelectOneElement) {\n                    if (!placeholderItem) {\n                        placeholderItem = this._getTemplate('placeholder', this.config.loadingText);\n                        this.itemList.append(placeholderItem);\n                    } else {\n                        placeholderItem.innerHTML = this.config.loadingText;\n                    }\n                } else {\n                    this.input.placeholder = this.config.loadingText;\n                }\n            } else {\n                this.enable();\n                this.containerOuter.removeLoadingState();\n                if (this._isSelectOneElement) {\n                    placeholderItem.innerHTML = this._placeholderValue || '';\n                } else {\n                    this.input.placeholder = this._placeholderValue || '';\n                }\n            }\n        }\n        _handleSearch(value) {\n            if (!value || !this.input.isFocussed) {\n                return;\n            }\n            const {choices} = this._store;\n            const {searchFloor, searchChoices} = this.config;\n            const hasUnactiveChoices = choices.some(option => !option.active);\n            if (value && value.length >= searchFloor) {\n                const resultCount = searchChoices ? this._searchChoices(value) : 0;\n                this.passedElement.triggerEvent(constants.EVENTS.search, {\n                    value,\n                    resultCount\n                });\n            } else if (hasUnactiveChoices) {\n                this._isSearching = false;\n                this._store.dispatch(d.activateChoices(true));\n            }\n        }\n        _canAddItem(activeItems, value) {\n            let canAddItem = true;\n            let notice = typeof this.config.addItemText === 'function' ? this.config.addItemText(value) : this.config.addItemText;\n            if (!this._isSelectOneElement) {\n                const isDuplicateValue = h.existsInArray(activeItems, value);\n                if (this.config.maxItemCount > 0 && this.config.maxItemCount <= activeItems.length) {\n                    canAddItem = false;\n                    notice = typeof this.config.maxItemText === 'function' ? this.config.maxItemText(this.config.maxItemCount) : this.config.maxItemText;\n                }\n                if (!this.config.duplicateItemsAllowed && isDuplicateValue && canAddItem) {\n                    canAddItem = false;\n                    notice = typeof this.config.uniqueItemText === 'function' ? this.config.uniqueItemText(value) : this.config.uniqueItemText;\n                }\n                if (this._isTextElement && this.config.addItems && canAddItem && typeof this.config.addItemFilter === 'function' && !this.config.addItemFilter(value)) {\n                    canAddItem = false;\n                    notice = typeof this.config.customAddItemText === 'function' ? this.config.customAddItemText(value) : this.config.customAddItemText;\n                }\n            }\n            return {\n                response: canAddItem,\n                notice\n            };\n        }\n        _searchChoices(value) {\n            const newValue = typeof value === 'string' ? value.trim() : value;\n            const currentValue = typeof this._currentValue === 'string' ? this._currentValue.trim() : this._currentValue;\n            if (newValue.length < 1 && newValue === `${ currentValue } `) {\n                return 0;\n            }\n            const haystack = this._store.searchableChoices;\n            const needle = newValue;\n            const keys = [...this.config.searchFields];\n            const options = Object.assign(this.config.fuseOptions, { keys });\n            const fuse = new Fuse(haystack, options);\n            const results = fuse.search(needle);\n            this._currentValue = newValue;\n            this._highlightPosition = 0;\n            this._isSearching = true;\n            this._store.dispatch(d.filterChoices(results));\n            return results.length;\n        }\n        _addEventListeners() {\n            const {documentElement} = document;\n            documentElement.addEventListener('touchend', this._onTouchEnd, true);\n            this.containerOuter.element.addEventListener('keydown', this._onKeyDown, true);\n            this.containerOuter.element.addEventListener('mousedown', this._onMouseDown, true);\n            documentElement.addEventListener('click', this._onClick, { passive: true });\n            documentElement.addEventListener('touchmove', this._onTouchMove, { passive: true });\n            this.dropdown.element.addEventListener('mouseover', this._onMouseOver, { passive: true });\n            if (this._isSelectOneElement) {\n                this.containerOuter.element.addEventListener('focus', this._onFocus, { passive: true });\n                this.containerOuter.element.addEventListener('blur', this._onBlur, { passive: true });\n            }\n            this.input.element.addEventListener('keyup', this._onKeyUp, { passive: true });\n            this.input.element.addEventListener('focus', this._onFocus, { passive: true });\n            this.input.element.addEventListener('blur', this._onBlur, { passive: true });\n            if (this.input.element.form) {\n                this.input.element.form.addEventListener('reset', this._onFormReset, { passive: true });\n            }\n            this.input.addEventListeners();\n        }\n        _removeEventListeners() {\n            const {documentElement} = document;\n            documentElement.removeEventListener('touchend', this._onTouchEnd, true);\n            this.containerOuter.element.removeEventListener('keydown', this._onKeyDown, true);\n            this.containerOuter.element.removeEventListener('mousedown', this._onMouseDown, true);\n            documentElement.removeEventListener('click', this._onClick);\n            documentElement.removeEventListener('touchmove', this._onTouchMove);\n            this.dropdown.element.removeEventListener('mouseover', this._onMouseOver);\n            if (this._isSelectOneElement) {\n                this.containerOuter.element.removeEventListener('focus', this._onFocus);\n                this.containerOuter.element.removeEventListener('blur', this._onBlur);\n            }\n            this.input.element.removeEventListener('keyup', this._onKeyUp);\n            this.input.element.removeEventListener('focus', this._onFocus);\n            this.input.element.removeEventListener('blur', this._onBlur);\n            if (this.input.element.form) {\n                this.input.element.form.removeEventListener('reset', this._onFormReset);\n            }\n            this.input.removeEventListeners();\n        }\n        _onKeyDown(event) {\n            const {target, keyCode, ctrlKey, metaKey} = event;\n            const {activeItems} = this._store;\n            const hasFocusedInput = this.input.isFocussed;\n            const hasActiveDropdown = this.dropdown.isActive;\n            const hasItems = this.itemList.hasChildren();\n            const keyString = String.fromCharCode(keyCode);\n            const {BACK_KEY, DELETE_KEY, ENTER_KEY, A_KEY, ESC_KEY, UP_KEY, DOWN_KEY, PAGE_UP_KEY, PAGE_DOWN_KEY} = constants.KEY_CODES;\n            const hasCtrlDownKeyPressed = ctrlKey || metaKey;\n            if (!this._isTextElement && /[a-zA-Z0-9-_ ]/.test(keyString)) {\n                this.showDropdown();\n            }\n            const keyDownActions = {\n                [A_KEY]: this._onAKey,\n                [ENTER_KEY]: this._onEnterKey,\n                [ESC_KEY]: this._onEscapeKey,\n                [UP_KEY]: this._onDirectionKey,\n                [PAGE_UP_KEY]: this._onDirectionKey,\n                [DOWN_KEY]: this._onDirectionKey,\n                [PAGE_DOWN_KEY]: this._onDirectionKey,\n                [DELETE_KEY]: this._onDeleteKey,\n                [BACK_KEY]: this._onDeleteKey\n            };\n            if (keyDownActions[keyCode]) {\n                keyDownActions[keyCode]({\n                    event,\n                    target,\n                    keyCode,\n                    metaKey,\n                    activeItems,\n                    hasFocusedInput,\n                    hasActiveDropdown,\n                    hasItems,\n                    hasCtrlDownKeyPressed\n                });\n            }\n        }\n        _onKeyUp({target, keyCode}) {\n            const {value} = this.input;\n            const {activeItems} = this._store;\n            const canAddItem = this._canAddItem(activeItems, value);\n            const {\n                BACK_KEY: backKey,\n                DELETE_KEY: deleteKey\n            } = constants.KEY_CODES;\n            if (this._isTextElement) {\n                const canShowDropdownNotice = canAddItem.notice && value;\n                if (canShowDropdownNotice) {\n                    const dropdownItem = this._getTemplate('notice', canAddItem.notice);\n                    this.dropdown.element.innerHTML = dropdownItem.outerHTML;\n                    this.showDropdown(true);\n                } else {\n                    this.hideDropdown(true);\n                }\n            } else {\n                const userHasRemovedValue = (keyCode === backKey || keyCode === deleteKey) && !target.value;\n                const canReactivateChoices = !this._isTextElement && this._isSearching;\n                const canSearch = this._canSearch && canAddItem.response;\n                if (userHasRemovedValue && canReactivateChoices) {\n                    this._isSearching = false;\n                    this._store.dispatch(d.activateChoices(true));\n                } else if (canSearch) {\n                    this._handleSearch(this.input.value);\n                }\n            }\n            this._canSearch = this.config.searchEnabled;\n        }\n        _onAKey({hasItems, hasCtrlDownKeyPressed}) {\n            if (hasCtrlDownKeyPressed && hasItems) {\n                this._canSearch = false;\n                const shouldHightlightAll = this.config.removeItems && !this.input.value && this.input.element === document.activeElement;\n                if (shouldHightlightAll) {\n                    this.highlightAll();\n                }\n            }\n        }\n        _onEnterKey({event, target, activeItems, hasActiveDropdown}) {\n            const {ENTER_KEY: enterKey} = constants.KEY_CODES;\n            const targetWasButton = target.hasAttribute('data-button');\n            if (this._isTextElement && target.value) {\n                const {value} = this.input;\n                const canAddItem = this._canAddItem(activeItems, value);\n                if (canAddItem.response) {\n                    this.hideDropdown(true);\n                    this._addItem({ value });\n                    this._triggerChange(value);\n                    this.clearInput();\n                }\n            }\n            if (targetWasButton) {\n                this._handleButtonAction(activeItems, target);\n                event.preventDefault();\n            }\n            if (hasActiveDropdown) {\n                const highlightedChoice = this.dropdown.getChild(`.${ this.config.classNames.highlightedState }`);\n                if (highlightedChoice) {\n                    if (activeItems[0]) {\n                        activeItems[0].keyCode = enterKey;\n                    }\n                    this._handleChoiceAction(activeItems, highlightedChoice);\n                }\n                event.preventDefault();\n            } else if (this._isSelectOneElement) {\n                this.showDropdown();\n                event.preventDefault();\n            }\n        }\n        _onEscapeKey({hasActiveDropdown}) {\n            if (hasActiveDropdown) {\n                this.hideDropdown(true);\n                this.containerOuter.focus();\n            }\n        }\n        _onDirectionKey({event, hasActiveDropdown, keyCode, metaKey}) {\n            const {\n                DOWN_KEY: downKey,\n                PAGE_UP_KEY: pageUpKey,\n                PAGE_DOWN_KEY: pageDownKey\n            } = constants.KEY_CODES;\n            if (hasActiveDropdown || this._isSelectOneElement) {\n                this.showDropdown();\n                this._canSearch = false;\n                const directionInt = keyCode === downKey || keyCode === pageDownKey ? 1 : -1;\n                const skipKey = metaKey || keyCode === pageDownKey || keyCode === pageUpKey;\n                const selectableChoiceIdentifier = '[data-choice-selectable]';\n                let nextEl;\n                if (skipKey) {\n                    if (directionInt > 0) {\n                        nextEl = this.dropdown.element.querySelector(`${ selectableChoiceIdentifier }:last-of-type`);\n                    } else {\n                        nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);\n                    }\n                } else {\n                    const currentEl = this.dropdown.element.querySelector(`.${ this.config.classNames.highlightedState }`);\n                    if (currentEl) {\n                        nextEl = h.getAdjacentEl(currentEl, selectableChoiceIdentifier, directionInt);\n                    } else {\n                        nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);\n                    }\n                }\n                if (nextEl) {\n                    if (!h.isScrolledIntoView(nextEl, this.choiceList.element, directionInt)) {\n                        this.choiceList.scrollToChildElement(nextEl, directionInt);\n                    }\n                    this._highlightChoice(nextEl);\n                }\n                event.preventDefault();\n            }\n        }\n        _onDeleteKey({event, target, hasFocusedInput, activeItems}) {\n            if (hasFocusedInput && !target.value && !this._isSelectOneElement) {\n                this._handleBackspace(activeItems);\n                event.preventDefault();\n            }\n        }\n        _onTouchMove() {\n            if (this._wasTap) {\n                this._wasTap = false;\n            }\n        }\n        _onTouchEnd(event) {\n            const {target} = event || event.touches[0];\n            const touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);\n            if (touchWasWithinContainer) {\n                const containerWasExactTarget = target === this.containerOuter.element || target === this.containerInner.element;\n                if (containerWasExactTarget) {\n                    if (this._isTextElement) {\n                        this.input.focus();\n                    } else if (this._isSelectMultipleElement) {\n                        this.showDropdown();\n                    }\n                }\n                event.stopPropagation();\n            }\n            this._wasTap = true;\n        }\n        _onMouseDown(event) {\n            const {target} = event;\n            if (!(target instanceof HTMLElement)) {\n                return;\n            }\n            if (IS_IE11 && this.choiceList.element.contains(target)) {\n                const firstChoice = this.choiceList.element.firstElementChild;\n                const isOnScrollbar = this._direction === 'ltr' ? event.offsetX >= firstChoice.offsetWidth : event.offsetX < firstChoice.offsetLeft;\n                this._isScrollingOnIe = isOnScrollbar;\n            }\n            if (target === this.input.element) {\n                return;\n            }\n            const item = target.closest('[data-button],[data-item],[data-choice]');\n            if (item instanceof HTMLElement) {\n                const hasShiftKey = event.shiftKey;\n                const {activeItems} = this._store;\n                const {dataset} = item;\n                if ('button' in dataset) {\n                    this._handleButtonAction(activeItems, item);\n                } else if ('item' in dataset) {\n                    this._handleItemAction(activeItems, item, hasShiftKey);\n                } else if ('choice' in dataset) {\n                    this._handleChoiceAction(activeItems, item);\n                }\n            }\n            event.preventDefault();\n        }\n        _onMouseOver({target}) {\n            if (target instanceof HTMLElement && 'choice' in target.dataset) {\n                this._highlightChoice(target);\n            }\n        }\n        _onClick({target}) {\n            const clickWasWithinContainer = this.containerOuter.element.contains(target);\n            if (clickWasWithinContainer) {\n                if (!this.dropdown.isActive && !this.containerOuter.isDisabled) {\n                    if (this._isTextElement) {\n                        if (document.activeElement !== this.input.element) {\n                            this.input.focus();\n                        }\n                    } else {\n                        this.showDropdown();\n                        this.containerOuter.focus();\n                    }\n                } else if (this._isSelectOneElement && target !== this.input.element && !this.dropdown.element.contains(target)) {\n                    this.hideDropdown();\n                }\n            } else {\n                const hasHighlightedItems = this._store.highlightedActiveItems.length > 0;\n                if (hasHighlightedItems) {\n                    this.unhighlightAll();\n                }\n                this.containerOuter.removeFocusState();\n                this.hideDropdown(true);\n            }\n        }\n        _onFocus({target}) {\n            const focusWasWithinContainer = this.containerOuter.element.contains(target);\n            if (!focusWasWithinContainer) {\n                return;\n            }\n            const focusActions = {\n                [constants.TEXT_TYPE]: () => {\n                    if (target === this.input.element) {\n                        this.containerOuter.addFocusState();\n                    }\n                },\n                [constants.SELECT_ONE_TYPE]: () => {\n                    this.containerOuter.addFocusState();\n                    if (target === this.input.element) {\n                        this.showDropdown(true);\n                    }\n                },\n                [constants.SELECT_MULTIPLE_TYPE]: () => {\n                    if (target === this.input.element) {\n                        this.showDropdown(true);\n                        this.containerOuter.addFocusState();\n                    }\n                }\n            };\n            focusActions[this.passedElement.element.type]();\n        }\n        _onBlur({target}) {\n            const blurWasWithinContainer = this.containerOuter.element.contains(target);\n            if (blurWasWithinContainer && !this._isScrollingOnIe) {\n                const {activeItems} = this._store;\n                const hasHighlightedItems = activeItems.some(item => item.highlighted);\n                const blurActions = {\n                    [constants.TEXT_TYPE]: () => {\n                        if (target === this.input.element) {\n                            this.containerOuter.removeFocusState();\n                            if (hasHighlightedItems) {\n                                this.unhighlightAll();\n                            }\n                            this.hideDropdown(true);\n                        }\n                    },\n                    [constants.SELECT_ONE_TYPE]: () => {\n                        this.containerOuter.removeFocusState();\n                        if (target === this.input.element || target === this.containerOuter.element && !this._canSearch) {\n                            this.hideDropdown(true);\n                        }\n                    },\n                    [constants.SELECT_MULTIPLE_TYPE]: () => {\n                        if (target === this.input.element) {\n                            this.containerOuter.removeFocusState();\n                            this.hideDropdown(true);\n                            if (hasHighlightedItems) {\n                                this.unhighlightAll();\n                            }\n                        }\n                    }\n                };\n                blurActions[this.passedElement.element.type]();\n            } else {\n                this._isScrollingOnIe = false;\n                this.input.element.focus();\n            }\n        }\n        _onFormReset() {\n            this._store.dispatch(misc.resetTo(this._initialState));\n        }\n        _highlightChoice(el = null) {\n            const choices = Array.from(this.dropdown.element.querySelectorAll('[data-choice-selectable]'));\n            if (!choices.length) {\n                return;\n            }\n            let passedEl = el;\n            const highlightedChoices = Array.from(this.dropdown.element.querySelectorAll(`.${ this.config.classNames.highlightedState }`));\n            highlightedChoices.forEach(choice => {\n                choice.classList.remove(this.config.classNames.highlightedState);\n                choice.setAttribute('aria-selected', 'false');\n            });\n            if (passedEl) {\n                this._highlightPosition = choices.indexOf(passedEl);\n            } else {\n                if (choices.length > this._highlightPosition) {\n                    passedEl = choices[this._highlightPosition];\n                } else {\n                    passedEl = choices[choices.length - 1];\n                }\n                if (!passedEl) {\n                    passedEl = choices[0];\n                }\n            }\n            passedEl.classList.add(this.config.classNames.highlightedState);\n            passedEl.setAttribute('aria-selected', 'true');\n            this.passedElement.triggerEvent(constants.EVENTS.highlightChoice, { el: passedEl });\n            if (this.dropdown.isActive) {\n                this.input.setActiveDescendant(passedEl.id);\n                this.containerOuter.setActiveDescendant(passedEl.id);\n            }\n        }\n        _addItem({value, label = null, choiceId = -1, groupId = -1, customProperties = null, placeholder = false, keyCode = null}) {\n            let passedValue = typeof value === 'string' ? value.trim() : value;\n            const passedKeyCode = keyCode;\n            const passedCustomProperties = customProperties;\n            const {items} = this._store;\n            const passedLabel = label || passedValue;\n            const passedOptionId = choiceId || -1;\n            const group = groupId >= 0 ? this._store.getGroupById(groupId) : null;\n            const id = items ? items.length + 1 : 1;\n            if (this.config.prependValue) {\n                passedValue = this.config.prependValue + passedValue.toString();\n            }\n            if (this.config.appendValue) {\n                passedValue += this.config.appendValue.toString();\n            }\n            this._store.dispatch(items.addItem({\n                value: passedValue,\n                label: passedLabel,\n                id,\n                choiceId: passedOptionId,\n                groupId,\n                customProperties,\n                placeholder,\n                keyCode: passedKeyCode\n            }));\n            if (this._isSelectOneElement) {\n                this.removeActiveItems(id);\n            }\n            this.passedElement.triggerEvent(constants.EVENTS.undefined, {\n                id,\n                value: passedValue,\n                label: passedLabel,\n                customProperties: passedCustomProperties,\n                groupValue: group && group.value ? group.value : undefined,\n                keyCode: passedKeyCode\n            });\n            return this;\n        }\n        _removeItem(item) {\n            if (!item || !h.isType('Object', item)) {\n                return this;\n            }\n            const {id, value, label, choiceId, groupId} = item;\n            const group = groupId >= 0 ? this._store.getGroupById(groupId) : null;\n            this._store.dispatch(items.removeItem(id, choiceId));\n            if (group && group.value) {\n                this.passedElement.triggerEvent(constants.EVENTS.undefined, {\n                    id,\n                    value,\n                    label,\n                    groupValue: group.value\n                });\n            } else {\n                this.passedElement.triggerEvent(constants.EVENTS.undefined, {\n                    id,\n                    value,\n                    label\n                });\n            }\n            return this;\n        }\n        _addChoice({value, label = null, isSelected = false, isDisabled = false, groupId = -1, customProperties = null, placeholder = false, keyCode = null}) {\n            if (typeof value === 'undefined' || value === null) {\n                return;\n            }\n            const {choices} = this._store;\n            const choiceLabel = label || value;\n            const choiceId = choices ? choices.length + 1 : 1;\n            const choiceElementId = `${ this._baseId }-${ this._idNames.itemChoice }-${ choiceId }`;\n            this._store.dispatch(d.addChoice({\n                id: choiceId,\n                groupId,\n                elementId: choiceElementId,\n                value,\n                label: choiceLabel,\n                disabled: isDisabled,\n                customProperties,\n                placeholder,\n                keyCode\n            }));\n            if (isSelected) {\n                this._addItem({\n                    value,\n                    label: choiceLabel,\n                    choiceId,\n                    customProperties,\n                    placeholder,\n                    keyCode\n                });\n            }\n        }\n        _addGroup({group, id, valueKey = 'value', labelKey = 'label'}) {\n            const groupChoices = h.isType('Object', group) ? group.choices : Array.from(group.getElementsByTagName('OPTION'));\n            const groupId = id || Math.floor(new Date().valueOf() * Math.random());\n            const isDisabled = group.disabled ? group.disabled : false;\n            if (groupChoices) {\n                this._store.dispatch(groups.addGroup({\n                    value: group.label,\n                    id: groupId,\n                    active: true,\n                    disabled: isDisabled\n                }));\n                const addGroupChoices = choice => {\n                    const isOptDisabled = choice.disabled || choice.parentNode && choice.parentNode.disabled;\n                    this._addChoice({\n                        value: choice[valueKey],\n                        label: h.isType('Object', choice) ? choice[labelKey] : choice.innerHTML,\n                        isSelected: choice.selected,\n                        isDisabled: isOptDisabled,\n                        groupId,\n                        customProperties: choice.customProperties,\n                        placeholder: choice.placeholder\n                    });\n                };\n                groupChoices.forEach(addGroupChoices);\n            } else {\n                this._store.dispatch(groups.addGroup({\n                    value: group.label,\n                    id: group.id,\n                    active: false,\n                    disabled: group.disabled\n                }));\n            }\n        }\n        _getTemplate(template, ...args) {\n            if (!template) {\n                return null;\n            }\n            const {classNames} = this.config;\n            return this._templates[template].call(this, classNames, ...args);\n        }\n        _createTemplates() {\n            const {callbackOnCreateTemplates} = this.config;\n            let userTemplates = {};\n            if (callbackOnCreateTemplates && typeof callbackOnCreateTemplates === 'function') {\n                userTemplates = callbackOnCreateTemplates.call(this, h.strToEl);\n            }\n            this._templates = merge(TEMPLATES, userTemplates);\n        }\n        _createElements() {\n            this.containerOuter = new components.Container({\n                element: this._getTemplate('containerOuter', this._direction, this._isSelectElement, this._isSelectOneElement, this.config.searchEnabled, this.passedElement.element.type),\n                classNames: this.config.classNames,\n                type: this.passedElement.element.type,\n                position: this.config.position\n            });\n            this.containerInner = new components.Container({\n                element: this._getTemplate('containerInner'),\n                classNames: this.config.classNames,\n                type: this.passedElement.element.type,\n                position: this.config.position\n            });\n            this.input = new components.Input({\n                element: this._getTemplate('input', this._placeholderValue),\n                classNames: this.config.classNames,\n                type: this.passedElement.element.type,\n                preventPaste: !this.config.paste\n            });\n            this.choiceList = new components.List({ element: this._getTemplate('choiceList', this._isSelectOneElement) });\n            this.itemList = new components.List({ element: this._getTemplate('itemList', this._isSelectOneElement) });\n            this.dropdown = new components.Dropdown({\n                element: this._getTemplate('dropdown'),\n                classNames: this.config.classNames,\n                type: this.passedElement.element.type\n            });\n        }\n        _createStructure() {\n            this.passedElement.conceal();\n            this.containerInner.wrap(this.passedElement.element);\n            this.containerOuter.wrap(this.containerInner.element);\n            if (this._isSelectOneElement) {\n                this.input.placeholder = this.config.searchPlaceholderValue || '';\n            } else if (this._placeholderValue) {\n                this.input.placeholder = this._placeholderValue;\n                this.input.setWidth();\n            }\n            this.containerOuter.element.appendChild(this.containerInner.element);\n            this.containerOuter.element.appendChild(this.dropdown.element);\n            this.containerInner.element.appendChild(this.itemList.element);\n            if (!this._isTextElement) {\n                this.dropdown.element.appendChild(this.choiceList.element);\n            }\n            if (!this._isSelectOneElement) {\n                this.containerInner.element.appendChild(this.input.element);\n            } else if (this.config.searchEnabled) {\n                this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);\n            }\n            if (this._isSelectElement) {\n                this._highlightPosition = 0;\n                this._isSearching = false;\n                this._startLoading();\n                if (this._presetGroups.length) {\n                    this._addPredefinedGroups(this._presetGroups);\n                } else {\n                    this._addPredefinedChoices(this._presetChoices);\n                }\n                this._stopLoading();\n            }\n            if (this._isTextElement) {\n                this._addPredefinedItems(this._presetItems);\n            }\n        }\n        _addPredefinedGroups(groups) {\n            const placeholderChoice = this.passedElement.placeholderOption;\n            if (placeholderChoice && placeholderChoice.parentNode.tagName === 'SELECT') {\n                this._addChoice({\n                    value: placeholderChoice.value,\n                    label: placeholderChoice.innerHTML,\n                    isSelected: placeholderChoice.selected,\n                    isDisabled: placeholderChoice.disabled,\n                    placeholder: true\n                });\n            }\n            groups.forEach(group => this._addGroup({\n                group,\n                id: group.id || null\n            }));\n        }\n        _addPredefinedChoices(choices) {\n            if (this.config.shouldSort) {\n                choices.sort(this.config.sorter);\n            }\n            const hasSelectedChoice = choices.some(choice => choice.selected);\n            const firstEnabledChoiceIndex = choices.findIndex(choice => choice.disabled === undefined || !choice.disabled);\n            choices.forEach((choice, index) => {\n                const {value, label, customProperties, placeholder} = choice;\n                if (this._isSelectElement) {\n                    if (choice.choices) {\n                        this._addGroup({\n                            group: choice,\n                            id: choice.id || null\n                        });\n                    } else {\n                        const shouldPreselect = this._isSelectOneElement && !hasSelectedChoice && index === firstEnabledChoiceIndex;\n                        const isSelected = shouldPreselect ? true : choice.selected;\n                        const isDisabled = choice.disabled;\n                        this._addChoice({\n                            value,\n                            label,\n                            isSelected,\n                            isDisabled,\n                            customProperties,\n                            placeholder\n                        });\n                    }\n                } else {\n                    this._addChoice({\n                        value,\n                        label,\n                        isSelected: choice.selected,\n                        isDisabled: choice.disabled,\n                        customProperties,\n                        placeholder\n                    });\n                }\n            });\n        }\n        _addPredefinedItems(items) {\n            items.forEach(item => {\n                if (typeof item === 'object' && item.value) {\n                    this._addItem({\n                        value: item.value,\n                        label: item.label,\n                        choiceId: item.id,\n                        customProperties: item.customProperties,\n                        placeholder: item.placeholder\n                    });\n                }\n                if (typeof item === 'string') {\n                    this._addItem({ value: item });\n                }\n            });\n        }\n        _setChoiceOrItem(item) {\n            const itemType = h.getType(item).toLowerCase();\n            const handleType = {\n                object: () => {\n                    if (!item.value) {\n                        return;\n                    }\n                    if (!this._isTextElement) {\n                        this._addChoice({\n                            value: item.value,\n                            label: item.label,\n                            isSelected: true,\n                            isDisabled: false,\n                            customProperties: item.customProperties,\n                            placeholder: item.placeholder\n                        });\n                    } else {\n                        this._addItem({\n                            value: item.value,\n                            label: item.label,\n                            choiceId: item.id,\n                            customProperties: item.customProperties,\n                            placeholder: item.placeholder\n                        });\n                    }\n                },\n                string: () => {\n                    if (!this._isTextElement) {\n                        this._addChoice({\n                            value: item,\n                            label: item,\n                            isSelected: true,\n                            isDisabled: false\n                        });\n                    } else {\n                        this._addItem({ value: item });\n                    }\n                }\n            };\n            handleType[itemType]();\n        }\n        _findAndSelectChoiceByValue(val) {\n            const {choices} = this._store;\n            const foundChoice = choices.find(choice => this.config.valueComparer(choice.value, val));\n            if (foundChoice && !foundChoice.selected) {\n                this._addItem({\n                    value: foundChoice.value,\n                    label: foundChoice.label,\n                    choiceId: foundChoice.id,\n                    groupId: foundChoice.groupId,\n                    customProperties: foundChoice.customProperties,\n                    placeholder: foundChoice.placeholder,\n                    keyCode: foundChoice.keyCode\n                });\n            }\n        }\n        _generatePlaceholderValue() {\n            if (this._isSelectElement) {\n                const {placeholderOption} = this.passedElement;\n                return placeholderOption ? placeholderOption.text : false;\n            }\n            const {placeholder, placeholderValue} = this.config;\n            const {\n                element: {dataset}\n            } = this.passedElement;\n            if (placeholder) {\n                if (placeholderValue) {\n                    return placeholderValue;\n                }\n                if (dataset.placeholder) {\n                    return dataset.placeholder;\n                }\n            }\n            return false;\n        }\n    }\n    return Choices;\n});\ndefine('skylark-choices/main',[\r\n\t\"./choices\"\r\n],function(Choices){\r\n\treturn Choices;\r\n});\ndefine('skylark-choices', ['skylark-choices/main'], function (main) { return main; });\n\n"]}